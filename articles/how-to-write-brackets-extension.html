<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="description" content=""><meta name="viewport" content="width=device-width, initial-scale=1"><title>如何编写一个 Brackets 插件 | Edward Chu's Blog</title><link rel="stylesheet" href="/assets/main.css"><script src="/assets/bundle.js"></script><script id="bdhm">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e18366090c703c986bb9172960f46513";
  hm.id = 'bdhm_js';
  hm.loaded = function(){
    delete window._bdhm_loaded_e18366090c703c986bb9172960f46513;
  }
  var s = document.getElementById('bdhm');
  s.parentNode.insertBefore(hm, s);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-57573368-1', 'auto');
ga('require', 'linkid', 'linkid.js');
ga('send', 'pageview');</script></head><body class="abs"><div class="leftbar"><div class="avatar card"><div class="sides"><div class="front"><a href="/" goback class="a-block"></a></div><div class="back invert"><div class="back-content"><a href="/" goback class="a-block"><div class="back-arrow"><span class="line top"></span><span class="line meat"></span><span class="line bottom"></span></div></a></div></div></div></div><div class="motto"><small>The Sensory World Is An Illusion.
<br>
原来心就是那个揣度者
</small></div><ul class="nav"><li class="nav-arrow"><a href="/" pjax>ARTICLES</a></li><li><a href="/archive.html" pjax>ARCHIVE</a></li><li><a href="/about.html" pjax>ABOUT</a></li></ul><div class="social"><span><a href="https://github.com/chuyik" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve" class="svg-icon"><path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761           c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32           c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472           c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037           C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65           c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261           c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082           c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129           c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path></svg></a></span><span><a href="https://twitter.com/chuyiktong" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 2000 1625.36" version="1.1" class="svg-icon"><path d="m 1999.9999,192.4 c -73.58,32.64 -152.67,54.69 -235.66,64.61 84.7,-50.78 149.77,-131.19 180.41,-227.01 -79.29,47.03 -167.1,81.17 -260.57,99.57 C 1609.3399,49.82 1502.6999,0 1384.6799,0 c -226.6,0 -410.328,183.71 -410.328,410.31 0,32.16 3.628,63.48 10.625,93.51 -341.016,-17.11 -643.368,-180.47 -845.739,-428.72 -35.324,60.6 -55.5583,131.09 -55.5583,206.29 0,142.36 72.4373,267.95 182.5433,341.53 -67.262,-2.13 -130.535,-20.59 -185.8519,-51.32 -0.039,1.71 -0.039,3.42 -0.039,5.16 0,198.803 141.441,364.635 329.145,402.342 -34.426,9.375 -70.676,14.395 -108.098,14.395 -26.441,0 -52.145,-2.578 -77.203,-7.364 52.215,163.008 203.75,281.649 383.304,284.946 -140.429,110.062 -317.351,175.66 -509.5972,175.66 -33.1211,0 -65.7851,-1.949 -97.8828,-5.738 181.586,116.4176 397.27,184.359 628.988,184.359 754.732,0 1167.462,-625.238 1167.462,-1167.47 0,-17.79 -0.41,-35.48 -1.2,-53.08 80.1799,-57.86 149.7399,-130.12 204.7499,-212.41"></path></svg></a></span><span><a href="http://www.zhihu.com/people/edward-chu-68" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" width="82.5px" height="85px" viewBox="0 0 82.5 85" xml:space="preserve" class="svg-icon"><path d="M39.238,69.526c-0.156,0.573-0.261,0.312-1.458-1.042c-2.812-3.28-5.416-6.769-8.176-10.102  c-0.781-0.938-1.25-1.459-1.562-1.562l3.645-4.062c1.875,2.237,6.666,7.968,8.541,10.206C41.06,64.109,40.174,66.712,39.238,69.526  L39.238,69.526z M43.507,46.092c-2.812-0.053-7.655-0.053-10.415,0c-2.135,0-3.125,0.416-3.229,2.708  c-0.053,1.458-0.521,2.917-0.782,4.375l-1.77,5.833c-1.458,3.854-3.125,7.603-5.78,10.779c-2.656,3.176-6.301,3.592-10.051,3.749  c-0.573,0-1.406,0.106-1.614-0.676c-0.208-0.729,0.521-1.095,0.989-1.511c3.958-3.228,7.135-7.082,9.582-11.611  c1.978-3.646,3.176-7.552,3.802-11.667c0.261-1.769-0.365-2.134-2.031-2.081c-3.073,0.103-8.905-0.053-11.978,0  c-0.104,0,0.104-0.261,0.261-1.146c0.312-2.344,2.186-4.062,3.905-4.062c2.656,0.051,5.676-0.104,8.332,0  c1.718,0.051,2.447-0.782,2.395-2.553c-0.051-4.009,0.052-8.071,0.157-12.081c0.052-1.146-0.417-1.511-1.51-1.562  c-3.49-0.313-3.854-0.105-5.52,3.124c-1.354,2.656-4.166,4.167-6.979,4.843c-1.509,0.365-1.353,0.313-1.197-0.156  c2.24-5.312,4.687-12.134,6.771-17.498c0.885-2.187,4.582-3.801,6.717-5.051c0,0,0.521-0.364,0,1.146  c-0.521,1.666-1.197,4.687-1.823,6.301c-0.625,1.718-0.313,2.604,1.405,2.552c5.104-0.052,10.519,0,15.623,0  c1.198,0,2.241-0.208,2.968,1.093c2.449,4.219,1.927,3.489-0.468,3.541c-2.031,0.053-5.729,0.053-7.76,0  c-1.562-0.052-2.187,0.47-2.396,2.136c-0.416,4.114-0.104,8.228-0.469,12.29c-0.104,1.458,0.833,1.771,1.875,1.771  c2.656,0,4.634-0.053,7.291,0c2.188,0.052,3.28,2.603,3.645,4.687C43.56,46.145,44.133,46.092,43.507,46.092L43.507,46.092z   M60.692,67.964l-7.863,5.728l-1.51-5.728h-5.208V20.575h26.559v0.105v47.284H60.692L60.692,67.964z M67.462,25.262H51.319v38.014  h2.083l1.509,4.738l7.344-4.738h5.208V25.262L67.462,25.262z"></path></svg></a></span><span><a href="/feed.xml" target="_blank"><svg style="width: 85%" viewBox="0 0 33 33" width="25" height="25" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="svg-icon"><path d="M 4.259,23.467c-2.35,0-4.259,1.917-4.259,4.252c0,2.349, 1.909,4.244, 4.259,4.244 c 2.358,0, 4.265-1.895, 4.265-4.244C 8.525,25.383, 6.618,23.467, 4.259,23.467zM 0.005,10.873l0,6.133 c 3.993,0, 7.749,1.562, 10.577,4.391c 2.825,2.822, 4.384,6.595, 4.384,10.603l 6.16,0 C 21.125,20.349, 11.648,10.873, 0.005,10.873zM 0.012,0l0,6.136 c 14.243,0, 25.836,11.604, 25.836,25.864L 32,32 C 32,14.36, 17.648,0, 0.012,0z"></path></svg></a></span><span><a href="mailto:crazyzyt@gmail.com?subject=Hi :)" title="Drop me an email"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve" class="svg-icon"><path d="M49.744,103.407v305.186H50.1h411.156h1V103.407H49.744z M415.533,138.407L255.947,260.465 L96.473,138.407H415.533z M84.744,173.506l85.504,65.441L84.744,324.45V173.506z M85.1,373.593l113.186-113.186l57.654,44.127 l57.375-43.882l112.941,112.94H85.1z M427.256,325.097l-85.896-85.896l85.896-65.695V325.097z"></path></svg></a></span></div></div><div class="main"><div class="main-content"><article><!--<Header></Header>--><!----><header class="article-header"><h1><a href="/articles/how-to-write-brackets-extension.html" pjax-page>如何编写一个 Brackets 插件</a></h1><time pubdate datetime="2015-01-07">2015-01-07</time></header><!--<Variables></Variables>--><!----><!--<Toc></Toc>--><!----><nav class="toc"><a href="#section0">从 Sublime 到 Brackets</a><a href="#section1">写一个简单插件</a><div><a href="#section2_0">本地创建一些文件</a><a href="#section2_1">package.json 基本结构</a><a href="#section2_2">main.js 基本结构</a><a href="#section2_3">运行插件</a><a href="#section2_4">调试（Debug）插件</a></div><a href="#section2">实现一个插入皮卡丘图形的插件</a><div><a href="#section3_0">package.json</a><a href="#section3_1">pikachu.txt</a><a href="#section3_2">读取外部静态文档</a><a href="#section3_3">添加菜单命令</a><a href="#section3_4">编辑当前文档</a><a href="#section3_5">Brackets 事件</a></div><a href="#section3">相关链接</a><a href="#section4">参考文章 Credits</a></nav><!--<Pagination></Pagination>--><!----><!--<Article>Content</Article>--><!----><div class="article-content"><p><a href="http://brackets.io/" title="Brackets - A modern, open source code editor that understands web design." target="_blank">Adobe Brackets</a> 是一个现代的 Web 开发编辑器，拥有着众多插件和粉丝。<br>Brackets 虽说由 Adobe 开发，但它却是开源且免费的。其开发语言为 JavaScript，因此迭代非常迅速。<br>虽说 Brackets 插件众多，却有一款至今找不着，所以便有了今天这篇文章。<br><!-- more --></p>
<h2 id="section0">从 Sublime 到 Brackets</h2>
<p>之前我一直在用 <a href="http://www.sublimetext.com/" target="_blank">Sublime Text</a>，它有着更多优秀的插件。但其实 Sublime 本身可定制的地方并不多，这很大程度上影响了插件功能的拓展。其次它并不针对于 Web 开发，所以当起 Web IDE 的角色来，还是比 Brackets 更逊色一些。要说最糟糕的是，Sublime 的更新已几乎停滞，与 Brackets 的「每月至少一个新特性」形成鲜明的对比。<br>因此我这次把 Brackets 从软件堆里拿出来，再对它审视了一番。发现插件比以前更丰富了，而且有些功能还蛮赞的。<br>只可惜 Brackets 的 Snippets 功能不如 Sublime 的强大，所以我写了一个插件来增强它（叫 <code>Brackets Snippets</code>，源码在 <a href="https://github.com/chuyik/brackets-snippets" target="_blank">Github</a>）。<br>而下面的入门教程，主要是基于这个插件（代码结构基本一致）。</p>
<h2 id="section1">写一个简单插件</h2>
<p>我们先从一个简单的插件入手，了解一些基本信息。</p>
<h3 id="section2_0">本地创建一些文件</h3>
<p>首先打开 Brackets，点击菜单的 <code>Help &gt; Show Extensions Folder</code>，打开插件所在的目录。进入 <code>user</code> 子目录，创建一个新文件夹，叫 <code>hello-my-world</code>，然后创建两个文件，分别名为 <code>main.js</code> 和 <code>package.json</code>。注意文件名是固定的。 </p>
<p><code>main.js</code>: 插件启动时运行的代码文件<br><code>package.json</code>: 插件的元信息</p>
<p> 最终文件结构如下：</p>
<pre class="tree">
├── hello-my-world/
│   ├── main.js
│   ├── package.json
</pre>

<h3 id="section2_1">package.json 基本结构</h3>
<p>这个文件保存的是插件的元信息，包括插件名称、描述、作者信息、协议等。<br>内容如下： </p>
<pre><code class="json">{
  "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">"hello-my-world"</span></span>,
  "<span class="hljs-attribute">title</span>": <span class="hljs-value"><span class="hljs-string">"Hello My World"</span></span>,
  "<span class="hljs-attribute">description</span>": <span class="hljs-value"><span class="hljs-string">"My first brackets extension, impressive!"</span></span>,
  "<span class="hljs-attribute">homepage</span>": <span class="hljs-value"><span class="hljs-string">"https://github.com/yourname/yourproject"</span></span>,
  "<span class="hljs-attribute">version</span>": <span class="hljs-value"><span class="hljs-string">"1.0.0"</span></span>,
  "<span class="hljs-attribute">author</span>": <span class="hljs-value"><span class="hljs-string">"Your Name &lt;your@email&gt; (http://your.url)"</span></span>,
  "<span class="hljs-attribute">license</span>": <span class="hljs-value"><span class="hljs-string">"MIT"</span></span>,
  "<span class="hljs-attribute">engines</span>": <span class="hljs-value">{
  "<span class="hljs-attribute">brackets</span>": <span class="hljs-value"><span class="hljs-string">"&gt;=0.24.0"</span>
  </span>}
</span>}</code></pre>
<p>其中必填的字段为 <code>name</code> 和 <code>version</code>，详细规则见 <a href="https://github.com/adobe/brackets/wiki/Extension-package-format#packagejson-format" title="Extension package format" target="_blank">Extension package format</a>。</p>
<h3 id="section2_2">main.js 基本结构</h3>
<p>这个文件在 Brackets 启动时会被自动加载，是插件运行的入口。<br>它的基本结构为：</p>
<pre><code class="javascript"><span class="hljs-comment">/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */</span>
<span class="hljs-comment">/*global define, $, brackets, window, Mustache */</span>

define(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(require, exports, module)</span> </span>{
<span class="hljs-pi">  "use strict"</span>;
  <span class="hljs-keyword">var</span> AppInit = brackets.getModule(<span class="hljs-string">"utils/AppInit"</span>);

  <span class="hljs-comment">// Brackets 初始化完成</span>
  AppInit.appReady(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Brackets 启动完毕后运行的代码</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello World'</span>);
    <span class="hljs-built_in">window</span>.alert(<span class="hljs-string">'Hello My World'</span>);
  });
});</code></pre>
<blockquote>
<p>全局变量</p>
<p>从上面的代码可以看出，我们有几个全局变量可以使用，分别是：<br><code>define</code>: 表示定义一个插件模块，来源于 <a href="http://requirejs.org/" title="RequireJS" target="_blank">RequireJS</a><br><code>$</code>: jQuery 对象，用于操纵 DOM 元素<br><code>brackets</code>: 用来访问软件中的其他模块，软件运行环境（系统语言、系统平台），软件版本等信息<br><code>window</code>: 浏览器全局对象<br><code>Mustache</code>: 模板语言，详细可以参考 <a href="https://github.com/janl/mustache.js" target="_blank">Mustache</a></p>
</blockquote>
<h3 id="section2_3">运行插件</h3>
<p>编辑保存好 main.js 和 package.json 后，点击菜单的 <code>Debug &gt; Reload With Extensions</code>（CMD+R / CTRL+R）来重新加载 Brackets 以运行最新的代码，如果弹出了一个 &quot;Hello My World&quot; 的对话框，则测试成功。</p>
<h3 id="section2_4">调试（Debug）插件</h3>
<p>点击菜单的 <code>Debug &gt; Show Developer Tools</code>，会弹出一个似曾相识的调试窗口。可以点击 <code>Sources</code> 选项卡进行断点调试，也可以点击 <code>Console</code> 选项卡直接运行些代码。<br>值得注意的是，当你第一次打开调试窗口，请务必点击右上角的设置按钮，选中 <code>Disable cache (while DevTools is open)</code>，确保没有缓存的干扰。</p>
<h2 id="section2">实现一个插入皮卡丘图形的插件</h2>
<p>了解基本的信息过后，我们可以尝试写一个插件，实现一个功能：<br>在文档某个位置插入皮卡丘的 ASCII 立体图。</p>
<blockquote>
<p><a href="http://zh.wikipedia.org/wiki/ASCII%E7%AB%8B%E4%BD%93%E5%9B%BE" target="_blank">ASCII 立体图</a></p>
<p>听到这个名字，或许会觉得陌生吧？<br>但其实这个东西在互联网上很常见啦，它是「火星文」、「颜文字」的鼻祖，主要通过字符排列引起视觉上的错觉。</p>
<p>喂喂下面这些字符你看破了嘛？</p>
<pre><code>  _|_|_|  _|    _|  _|_|_|    _|_|_|_|  _|_|_|
_|        _|    _|  _|    _|  _|        _|    _|
  _|_|    _|    _|  _|_|_|    _|_|_|    _|_|_|
      _|  _|    _|  _|        _|        _|    _|
_|_|_|      _|_|    _|        _|_|_|_|  _|    _|

_|      _|    _|_|    _|_|_|    _|_|_|    _|_|
_|_|  _|_|  _|    _|  _|    _|    _|    _|    _|
_|  _|  _|  _|_|_|_|  _|_|_|      _|    _|    _|
_|      _|  _|    _|  _|    _|    _|    _|    _|
_|      _|  _|    _|  _|    _|  _|_|_|    _|_|</code></pre>
</blockquote>
<p>这部分我们另起炉灶，创建一个新的插件，叫 <code>ascii-pokemon</code>。</p>
<p>目录结构如下：</p>
<pre class="tree">
├── ascii-pokemon/
│   ├── main.js
│   ├── package.json
│   ├── pikachu.txt
</pre>

<h3 id="section3_0">package.json</h3>
<p>这里提供一些必要字段，其他字段可以参考前面的介绍。</p>
<pre><code class="json">{
  "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">"ascii-pokemon"</span></span>,
  "<span class="hljs-attribute">title</span>": <span class="hljs-value"><span class="hljs-string">"ASCII Pokemon"</span></span>,
  "<span class="hljs-attribute">version</span>": <span class="hljs-value"><span class="hljs-string">"1.0.0"</span>
</span>}</code></pre>
<h3 id="section3_1">pikachu.txt</h3>
<p><code>pikachu</code> 是什么东西？其实就是皮卡丘的英文名字啦！<br>我们利用这个文件，存储皮卡丘的图形。<br>把下面这个复制进去（来源于<a href="http://www.fiikus.net/?pokedex" target="_blank">这个网站</a>，有第一代的所有宠物）：</p>
<pre><code>                                             ,-.
                                          _.|  &#39;
                                        .&#39;  | /
                                      ,&#39;    |&#39;
                                     /      /
                       _..----&quot;&quot;---.&#39;      /
 _.....---------...,-&quot;&quot;                  ,&#39;
 `-._  \                                /
     `-.+_            __           ,--. .
          `-.._     .:  ).        (`--&quot;| \
               7    | `&quot; |         `...&#39;  \
               |     `--&#39;     &#39;+&quot;        ,&quot;. ,&quot;&quot;-
               |   _...        .____     | |/    &#39;
          _.   |  .    `.  &#39;--&quot;   /      `./     j
         \&#39; `-.|  &#39;     |   `.   /        /     /
         &#39;     `-. `---&quot;      `-&quot;        /     /
          \       `.                  _,&#39;     /
           \        `                        .
            \                                j
             \                              /
              `.                           .
                +                          \
                |                           L
                |                           |
                |  _ /,                     |
                | | L)&#39;..                   |
                | .    | `                  |
                &#39;  \&#39;   L                   &#39;
                 \  \   |                  j
                  `. `__&#39;                 /
                _,.--.---........__      /
               ---.,&#39;---`         |   -j&quot;
                .-&#39;  &#39;....__      L    |
              &quot;&quot;--..    _,-&#39;       \ l||
                  ,-&#39;  .....------. `||&#39;
               _,&#39;                /
             ,&#39;                  /
            &#39;---------+-        /
                     /         /
                   .&#39;         /
                 .&#39;          /
               ,&#39;           /
             _&#39;....----&quot;&quot;&quot;&quot;&quot; mh</code></pre>
<h3 id="section3_2">读取外部静态文档</h3>
<p>如果想在代码中读取一些 <code>json</code> 或者 <code>txt</code> 文档的内容，就可以使用 <code>require</code> 方法。<br>由于内置的第三方依赖管理工具是 <code>RequireJS</code>，所以在读取文本的时候，要在路径前加上 <code>text!</code> 的前缀。</p>
<p>使用 <code>require</code> 读取静态文档内容：</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> pikachu = <span class="hljs-built_in">require</span>(<span class="hljs-string">'text!pikachu.txt'</span>);</code></pre>
<p>整合前面提及的 <code>main.js</code> 基本结构后，最新的代码为：</p>
<pre><code class="javascript"><span class="hljs-comment">/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */</span>
<span class="hljs-comment">/*global define, $, brackets, window, Mustache */</span>

define(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(require, exports, module)</span> </span>{
<span class="hljs-pi">  "use strict"</span>;

  <span class="hljs-keyword">var</span> AppInit  = brackets.getModule(<span class="hljs-string">'utils/AppInit'</span>),
      pikachu  = <span class="hljs-built_in">require</span>(<span class="hljs-string">'text!pikachu.txt'</span>);

  AppInit.appReady(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">console</span>.log(pikachu);
  });
});</code></pre>
<p>保存完后，打开调试窗口，重新加载一下 Brackets（CMD+R / CTRL+R），就会看到调试窗口中出现了皮卡丘可爱的身影。<br>只可惜如果想再召唤出皮卡丘，就只能再加载一次 Brackets。这未免太坑爹了吧？<br>为了可以无限使用精灵球，我们可以把「召唤」这个命令写进菜单里，这样就可以随召随到啦！<br>为了达到这个目的，我们来了解下 Brackets 的菜单。</p>
<h3 id="section3_3">添加菜单命令</h3>
<p>Brackets 菜单模块叫做 <code>Menus</code>，可以通过 <code>brackets.getModule(&quot;command/Menus&quot;)</code> 获得。<br>菜单对象分为「菜单栏的菜单 Menu」和「右键菜单 ContextMenu」，每个对象都有一个固定的 ID。</p>
<p>菜单栏上可以看到有 <code>File/Edit/...</code> 等菜单对象，它们的 ID 分别是：</p>
<blockquote>
<ul>
<li>File <code>FILE_MENU</code></li>
<li>Edit <code>EDIT_MENU</code></li>
<li>Find <code>FIND_MENU</code></li>
<li>View <code>VIEW_MENU</code></li>
<li>Navigate <code>NAVIGATE_MENU</code></li>
<li>Help <code>HELP_MENU</code></li>
</ul>
</blockquote>
<p>而右键菜单主要根据点击的区域而不同，这些区域和菜单对象 ID 分别是：</p>
<blockquote>
<ul>
<li>文本编辑区域 <code>EDITOR_MENU</code></li>
<li>行内编辑区域 <code>INLINE_EDITOR_MENU</code>（即点击 <code>Quick Edit</code> 后出现的编辑区域）</li>
<li>文件目录树区域 <code>PROJECT_MENU</code></li>
<li>已打开的文件区域 <code>WORKING_SET_CONTEXT_MENU</code>（即「文件目录树」上方区域）</li>
<li>点击排序按钮出现的菜单 <code>WORKING_SET_CONFIG_MENU</code>（即「已打开的文件区域」右上角按钮）</li>
<li>点击分割视图按钮出现的菜单 <code>SPLITVIEW_MENU</code>（即「已打开的文件区域」右上角按钮）</li>
</ul>
</blockquote>
<p>若想要完成「添加自定义菜单，点击菜单时完成某个指令」的操作，需要调用以下三个方法：</p>
<blockquote>
<ol>
<li><a href="http://brackets.io/docs/current/modules/command/CommandManager.html#-register" target="_blank">CommandManager.register(name, id, commandFn)</a> 注册某个指令，以便于和菜单进行绑定。</li>
<li><a href="http://brackets.io/docs/current/modules/command/Menus.html#-getMenu" target="_blank">Menus.getMenu(menuId)</a> 提供上面提到的菜单 ID，获取相对应的菜单对象。</li>
<li><a href="http://brackets.io/docs/current/modules/command/Menus.html#Menu-addMenuItem" target="_blank">menu.addMenuItem(commandID, keyBindings)</a> 将已注册的指令 ID 添加到某个菜单对象去。</li>
</ol>
</blockquote>
<p>具体实现的代码：</p>
<pre><code class="javascript"><span class="hljs-comment">/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */</span>
<span class="hljs-comment">/*global define, $, brackets, window, Mustache */</span>

define(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(require, exports, module)</span> </span>{
<span class="hljs-pi">  "use strict"</span>;

  <span class="hljs-keyword">var</span> AppInit        = brackets.getModule(<span class="hljs-string">'utils/AppInit'</span>),
      CommandManager = brackets.getModule(<span class="hljs-string">"command/CommandManager"</span>),
      Menus          = brackets.getModule(<span class="hljs-string">"command/Menus"</span>),
      pikachu        = <span class="hljs-built_in">require</span>(<span class="hljs-string">'text!pikachu.txt'</span>);

  <span class="hljs-comment">// 菜单点击时执行的函数</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commandHandler</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">console</span>.log(pikachu);
  }

  <span class="hljs-comment">// 命令 ID（注意要唯一）</span>
  <span class="hljs-keyword">var</span> COMMAND_ID = <span class="hljs-string">"ascii-pokemon.pikachu"</span>;
  <span class="hljs-comment">// 注册命令（提供三个参数，分别为：用于显示的命令名称、命令 ID、回调函数）</span>
  CommandManager.register(<span class="hljs-string">"召唤皮卡丘"</span>, COMMAND_ID, commandHandler);

  <span class="hljs-comment">// `Edit` 菜单对象</span>
  <span class="hljs-keyword">var</span> menu = Menus.getMenu(Menus.AppMenuBar.EDIT_MENU);
  <span class="hljs-comment">// 文本编辑区域的右键菜单对象</span>
  <span class="hljs-keyword">var</span> contextMenu = Menus.getContextMenu(Menus.ContextMenuIds.EDITOR_MENU);

  <span class="hljs-comment">// 把命令添加到菜单去</span>
  menu.addMenuItem(COMMAND_ID);
  contextMenu.addMenuItem(COMMAND_ID);

  AppInit.appReady(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 留空</span>
  });
});</code></pre>
<p>保存文件之后，需要重新加载 Brackets。加载完毕后，你会发现 <code>Edit</code> 菜单和编辑区域的右键菜单多了一个中文命令。点击一下它，再看看调试窗口是否成功。<br>但目前为止，皮卡丘还只是活在调试窗口中耶。这样不行了啦，我们还想要把它带到 Brackets 的核心，那就是文档编辑区域。<br>下面我们来看看来了解一下通过操作 <code>Editor</code> 和 <code>Document</code> 的实例，实现这个目的。</p>
<h3 id="section3_4">编辑当前文档</h3>
<p>Brackets 每个已打开的文档都是一个对象，均为 <code>Document</code> 的子类。<br>而每个文档所对应的编辑器，就是 <code>Editor</code>，与 <code>Document</code> 为一对一的关系。</p>
<p>获取 <code>Editor</code> 对象的几种方法：</p>
<blockquote>
<ul>
<li><code>EditorManager.getFocusedEditor()</code> 返回当前获得焦点的编辑器对象</li>
<li><code>EditorManager.getActiveEditor()</code> 返回当前正在编辑的编辑器对象。和上面的方法相似，区别在于如果当前焦点被转移到了搜索栏、对话框等地方，就会返回最后一个获得焦点的编辑器对象</li>
<li><code>EditorManager.getCurrentFullEditor()</code> 返回当前打开的文本的编辑器对象，不包括行内编辑器（Inline Editor，即通过 <code>Quick Edit</code> 打开的编辑器）</li>
</ul>
</blockquote>
<p>获得 <code>Editor</code> 对象之后，<code>Document</code> 对象就垂手可得了：</p>
<pre><code class="javascript">  <span class="hljs-keyword">var</span> <span class="hljs-built_in">document</span> = editor.document;</code></pre>
<p>下面要介绍的是 <code>Editor</code> 和 <code>Document</code> 一些常用的方法。</p>
<p><strong>Editor 对象</strong></p>
<blockquote>
<ul>
<li><a href="http://brackets.io/docs/current/modules/editor/Editor.html#Editor-getCursorPos" target="_blank">getCursorPos()</a> 返回光标的位置。注意位置的格式为：<code>{line:number, ch:number}</code>，下同</li>
<li><a href="http://brackets.io/docs/current/modules/editor/Editor.html#Editor-getSelectedText" target="_blank">getSelectedText()</a> 返回当前被选中的内容</li>
<li><a href="http://brackets.io/docs/current/modules/editor/Editor.html#Editor-setSelection" target="_blank">setSelection(start, end)</a> 选中某个范围的内容</li>
<li><a href="http://brackets.io/docs/current/modules/editor/Editor.html#Editor-selectWordAt" target="_blank">selectWordAt(position)</a> 选中某个位置上的单词</li>
</ul>
</blockquote>
<p><strong>Document 对象</strong></p>
<blockquote>
<ul>
<li><a href="http://brackets.io/docs/current/modules/document/Document.html#Document-getText" target="_blank">getText()</a> 返回当前文本的所有内容，包括未保存的部分</li>
<li><a href="http://brackets.io/docs/current/modules/document/Document.html#Document-setText" target="_blank">setText(text)</a> 替换当前文本的所有内容</li>
<li><a href="http://brackets.io/docs/current/modules/document/Document.html#Document-getLine" target="_blank">getLine(number)</a> 返回某行的文本内容</li>
<li><a href="http://brackets.io/docs/current/modules/document/Document.html#Document-getRange" target="_blank">getRange(start, end)</a> 返回某个范围的所有内容</li>
<li><a href="http://brackets.io/docs/current/modules/document/Document.html#Document-replaceRange" target="_blank">replaceRange(text, start, end)</a> 替换某个范围的所有内容</li>
</ul>
</blockquote>
<p>结合上面一些 API 提供的方法，我们实现一个功能：「在文档光标所在的位置召唤出皮卡丘」。</p>
<p>具体代码如下：</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> EditorManager  = brackets.getModule(<span class="hljs-string">"editor/EditorManager"</span>);

<span class="hljs-comment">// 菜单点击时执行的函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commandHandler</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// 获取当前打开的文本的编辑器对象</span>
  <span class="hljs-keyword">var</span> editor = EditorManager.getCurrentFullEditor();

  <span class="hljs-keyword">if</span> (editor) {
    <span class="hljs-comment">// 获取光标位置，格式为：CodeMirror.Pos {line: 16, ch: 7}</span>
    <span class="hljs-keyword">var</span> insertionPos = editor.getCursorPos();

    <span class="hljs-comment">// 在光标后面插入皮卡丘图形</span>
    editor.document.replaceRange(pikachu, insertionPos);
  }
}</code></pre>
<p>将上面的代码与原来的合并之后，重新加载 Brackets，将光标放在文档的任意位置，点击右键「召唤皮卡丘」，是不是就出来了？<br>好了，目前为止我们已经获得了不错的效果，但是好像通过点击菜单的方式还是有点麻烦。<br>对于程序员而言，假如我们敲击咒语 <code>pikapika</code>，再按下 <code>Tab</code> 键，皮卡丘就出来了岂不是更爽？<br>因此接下来，让我们一起了解下 Brackets 的事件机制。</p>
<h3 id="section3_5">Brackets 事件</h3>
<p>Brackets 主要利用 jQuery 来进行事件的分发。了解 jQuery 的同学都知道其绑定事件和解绑事件的方法分别是 <code>$(obj).on()</code> 和 <code>$(obj).off()</code>，Brackets 中同样如此。</p>
<p>下面介绍 <code>Editor</code> 对象中支持的事件：</p>
<blockquote>
<ul>
<li><code>keydown, keypress, keyup</code> 当任意按键按下时，会触发这几个事件。回调函数接收 <code>(BracketsEvent, Editor, KeyboardEvent)</code> 参数</li>
<li><code>cursorActivity</code> 当用户移动光标、选中的字符有变动、有修改操作，均会触发此事件。注意由于这个事件威力太猛，所以不建议监听，但可以换成 <code>$(editor.document).on(&#39;change&#39;, changeHandler)</code></li>
<li><code>scroll</code> 当编辑器有滚动的操作触发</li>
<li><code>lostContent</code> 当文档内容丢失时触发</li>
<li><code>optionChange</code> 当因选项变动导致编辑器发生改变时触发</li>
<li><code>beforeDestroy</code> 当编辑器对象被销毁时触发</li>
</ul>
</blockquote>
<p>对于监听键盘敲击事件而言，我们常用 <code>keypress</code> 事件。但如果涉及到功能键（如 Tab/Ctrl/Shift）的话，则要改用 <code>keydown</code> 事件。因此这里我们选择监听后者。</p>
<p>具体代码如下：</p>
<pre><code class="javascript">  <span class="hljs-keyword">var</span> EditorManager = brackets.getModule(<span class="hljs-string">"editor/EditorManager"</span>);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">keyHandler</span> <span class="hljs-params">(bracketsEvent, editor, keyboardEvent)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'keycode: '</span>, keyboardEvent.keyCode);
  }

  AppInit.appReady(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> editor = EditorManager.getCurrentFullEditor();
    $(editor).on(<span class="hljs-string">"keydown"</span>, keyHandler);
  });</code></pre>
<p>然而当你整合完代码后会发现，代码好像并没有执行，或者说切换另一个文档的时候，代码就失效了。<br>为了确保代码始终对当前文档有效，我们还要再监听 <code>EditorManager</code> 的 <code>activeEditorChange</code> 事件。</p>
<p>具体代码如下：</p>
<pre><code class="javascript">  <span class="hljs-keyword">var</span> EditorManager  = brackets.getModule(<span class="hljs-string">"editor/EditorManager"</span>);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">keyHandler</span> <span class="hljs-params">(bracketsEvent, editor, keyboardEvent)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'keycode: '</span>, keyboardEvent.keyCode);
  }

  <span class="hljs-comment">// 文档切换时重新绑定监听事件</span>
  <span class="hljs-keyword">var</span> activeEditorChangeHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(bracketsEvent, focusedEditor, lostEditor)</span> </span>{
    <span class="hljs-keyword">if</span> (lostEditor) {
      $(lostEditor).off(<span class="hljs-string">"keydown"</span>, keyHandler);
    }

    <span class="hljs-keyword">if</span> (focusedEditor) {
      $(focusedEditor).on(<span class="hljs-string">"keydown"</span>, keyHandler);
    }
  };

  AppInit.appReady(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 绑定文档切换事件</span>
    $(EditorManager).on(<span class="hljs-string">'activeEditorChange'</span>, activeEditorChangeHandler);
  });</code></pre>
<p>目前我们已经了解了 <code>Editor</code> 对象的一些方法和它的监听事件。因此我们很容易地实现最后一个功能：「敲击咒语 <code>pikapika</code>，再按下 <code>Tab</code> 键，召唤出皮卡丘」。</p>
<p>具体实现代码：</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> KeyEvent = brackets.getModule(<span class="hljs-string">"utils/KeyEvent"</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">keyHandler</span> <span class="hljs-params">(bracketsEvent, editor, keyboardEvent)</span> </span>{

  <span class="hljs-comment">// 如果用户按键不是 Tab 键，返回</span>
  <span class="hljs-keyword">if</span> (keyboardEvent.keyCode !== KeyEvent.DOM_VK_TAB) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 获取当前光标位置</span>
  <span class="hljs-keyword">var</span> cursorPos = editor.getCursorPos();

  <span class="hljs-comment">// 获取当前行的所有文字</span>
  <span class="hljs-keyword">var</span> lineStr = editor.document.getLine(cursorPos.line);

  <span class="hljs-comment">// 咒语</span>
  <span class="hljs-keyword">var</span> mantra = <span class="hljs-string">'pikapika'</span>;

  <span class="hljs-comment">// 判断光标前的字符与咒语是否一致</span>
  <span class="hljs-keyword">if</span> (mantra === lineStr.substr(cursorPos.ch - mantra.length, cursorPos.ch)) {
    <span class="hljs-keyword">var</span> start = {
        line: cursorPos.line,
        ch: cursorPos.ch - mantra.length
    };
    <span class="hljs-comment">// 在光标后面插入皮卡丘图形</span>
    editor.document.replaceRange(pikachu, start, cursorPos);
  }
}</code></pre>
<p>整合前面提及的所有东西，<strong>最终完整的代码</strong>如下：</p>
<pre><code class="javascript"><span class="hljs-comment">/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */</span>
<span class="hljs-comment">/*global define, $, brackets, window, Mustache */</span>

define(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(require, exports, module)</span> </span>{
<span class="hljs-pi">  "use strict"</span>;

  <span class="hljs-keyword">var</span> AppInit        = brackets.getModule(<span class="hljs-string">'utils/AppInit'</span>),
      CommandManager = brackets.getModule(<span class="hljs-string">"command/CommandManager"</span>),
      EditorManager  = brackets.getModule(<span class="hljs-string">"editor/EditorManager"</span>),
      Menus          = brackets.getModule(<span class="hljs-string">"command/Menus"</span>),
      KeyEvent       = brackets.getModule(<span class="hljs-string">"utils/KeyEvent"</span>),
      pikachu        = <span class="hljs-built_in">require</span>(<span class="hljs-string">'text!pikachu.txt'</span>);

  <span class="hljs-comment">// 菜单点击时执行的函数</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commandHandler</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 获取当前打开的文本的编辑器对象</span>
    <span class="hljs-keyword">var</span> editor = EditorManager.getCurrentFullEditor();

    <span class="hljs-keyword">if</span> (editor) {
      <span class="hljs-comment">// 获取光标位置，格式为：CodeMirror.Pos {line: 16, ch: 7}</span>
      <span class="hljs-keyword">var</span> insertionPos = editor.getCursorPos();

      <span class="hljs-comment">// 在光标后面插入皮卡丘图形</span>
      editor.document.replaceRange(pikachu, insertionPos);
    }
  }

  <span class="hljs-comment">// 命令 ID（注意要唯一）</span>
  <span class="hljs-keyword">var</span> COMMAND_ID = <span class="hljs-string">"ascii-pokemon.pikachu"</span>;
  <span class="hljs-comment">// 注册命令（提供三个参数，分别为：用于显示的命令名称、命令 ID、回调函数）</span>
  CommandManager.register(<span class="hljs-string">"召唤皮卡丘"</span>, COMMAND_ID, commandHandler);

  <span class="hljs-comment">// `Edit` 菜单对象</span>
  <span class="hljs-keyword">var</span> menu = Menus.getMenu(Menus.AppMenuBar.EDIT_MENU);
  <span class="hljs-comment">// 文本编辑区域的右键菜单对象</span>
  <span class="hljs-keyword">var</span> contextMenu = Menus.getContextMenu(Menus.ContextMenuIds.EDITOR_MENU);

  <span class="hljs-comment">// 把命令添加到菜单去</span>
  menu.addMenuItem(COMMAND_ID);
  contextMenu.addMenuItem(COMMAND_ID);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">keyHandler</span> <span class="hljs-params">(bracketsEvent, editor, keyboardEvent)</span> </span>{

    <span class="hljs-comment">// 如果用户按键不是 Tab 键，返回</span>
    <span class="hljs-keyword">if</span> (keyboardEvent.keyCode !== KeyEvent.DOM_VK_TAB) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 获取当前光标位置</span>
    <span class="hljs-keyword">var</span> cursorPos = editor.getCursorPos();

    <span class="hljs-comment">// 获取当前行的所有文字</span>
    <span class="hljs-keyword">var</span> lineStr = editor.document.getLine(cursorPos.line);

    <span class="hljs-comment">// 咒语</span>
    <span class="hljs-keyword">var</span> mantra = <span class="hljs-string">'pikapika'</span>;

    <span class="hljs-comment">// 判断光标前的字符与咒语是否一致</span>
    <span class="hljs-keyword">if</span> (mantra === lineStr.substr(cursorPos.ch - mantra.length, cursorPos.ch)) {
      <span class="hljs-keyword">var</span> start = {
          line: cursorPos.line,
          ch: cursorPos.ch - mantra.length
      };
      <span class="hljs-comment">// 在光标后面插入皮卡丘图形</span>
      editor.document.replaceRange(pikachu, start, cursorPos);
    }
  }

  <span class="hljs-comment">// 切换文件编辑窗口，重新绑定按键监听事件</span>
  <span class="hljs-keyword">var</span> activeEditorChangeHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(bracketsEvent, focusedEditor, lostEditor)</span> </span>{
    <span class="hljs-keyword">if</span> (lostEditor) {
      $(lostEditor).off(<span class="hljs-string">"keydown"</span>, keyHandler);
    }

    <span class="hljs-keyword">if</span> (focusedEditor) {
      $(focusedEditor).on(<span class="hljs-string">"keydown"</span>, keyHandler);
    }
  };

  AppInit.appReady(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 绑定文档切换事件</span>
    $(EditorManager).on(<span class="hljs-string">'activeEditorChange'</span>, activeEditorChangeHandler);
  });
});</code></pre>
<p>好了，如果你看到了这里，说明你已经掌握了如何制作一个 Brackets 插件。<br>接下来，你可以尝试查看其他插件的源码，甚至是 Brackets 的源码进行学习。<br>下面是一些开发的相关链接，希望能给你带来更多的帮助。</p>
<h2 id="section3">相关链接</h2>
<p><a href="http://brackets.io/docs/current/modules/editor/Editor.html" target="_blank">Brackets API</a><br><a href="https://github.com/adobe/brackets/wiki" target="_blank">Brackets Wiki</a><br><a href="https://groups.google.com/forum/?hl=en#!forum/brackets-dev" target="_blank">Brackets 开发论坛</a><br><a href="http://codemirror.net/" target="_blank">CodeMirror - Brackets Editor 核心</a></p>
<h2 id="section4">参考文章 Credits</h2>
<p><a href="https://github.com/adobe/brackets/wiki/How-to-write-extensions" target="_blank">How to write extensions · adobe/brackets Wiki</a><br><a href="http://artoale.com/tutorial/brackets/2013/10/04/writing-brackets-extension-02/" target="_blank">Writing Brackets extension - part 2</a><br><a href="http://www.adobe.com/cn/devnet/edge-code/articles/building-your-first-brackets-extension.html" target="_blank">构建首个 Brackets 扩展 | Adobe 开发人员连接</a></p>
</div><!--<Footer></Footer>--><!----><footer><div class="license"><span><a style="color: #444" href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank">CC BY-NC-SA 3.0 License</a></span></div></footer><!--<Inline>Function</Inline>--><!----></article></div></div><div class="footer"><div class="back-to-top footer-float-btn">^</div><div><a style="color: #AAA;" title="View Source Code" href="https://github.com/chuyik/chuyik.github.io/tree/harp" target="_blank">IMAO I design it myself.</a><div style="margin:0 0 5px 0"><small style="color: #CCC;">Powered by<a style="color: #CCC; padding: 0 0 0 3px" href="http://harpjs.com" target="_blank">Harp</a></small></div></div></div></body></html>