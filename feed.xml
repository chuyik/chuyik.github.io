<?xml version="1.0" encoding="utf-8" ?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Edward Chu's Blog</title><link>http://edwardchu.org</link><description>A front-end focused blog.</description><atom:link href="http://edwardchu.org/feed.xml" rel="self" type="application/rss+xml"></atom:link><item><title>可恶的 GraphicsMagick</title><description><![CDATA[<p>今天在用 <a href="www.graphicsmagick.org">GraphicsMagick</a> (简写 gm) 处理 jpeg 的时候，不幸遇到了这个错误：<br><code>Wrong JPEG library version: library is 62, caller expects 80</code>。<br><!-- more --></p>
<p>出现这个情况，是由系统的 libjpeg 版本号和 gm 调用的不一致而导致的。</p>
<p>解决方法，无非就是安装对应的 libjpeg 和 gm。</p>
<h1>解决步骤</h1>
<ol>
<li><p>把 /usr/local/lib 和 /usr/lib64 中的 libjpeg* 全部删除，避免版本冲突</p>
<pre><code class="bash">rm -r /usr/<span class="hljs-built_in">local</span>/lib/libjpeg*
rm -r /usr/lib64/libjpeg*</code></pre>
</li>
<li><p>删除系统现有的 libjpeg 和 libjpeg-turbo 库</p>
<pre><code class="bash">rpm -qa | grep libjpeg  <span class="hljs-comment"># 检查是否有 libjpeg 库</span>
rpm -qa | grep libjpeg | xargs rpm <span class="hljs-operator">-e</span> --nodeps --allmatches <span class="hljs-comment"># 有的都删掉</span></code></pre>
</li>
<li><p>下载 libjpeg 源码<br>由于错误提示是要80版本，所以建议下载 libjpeg.8.x。<br>下载地址：ftp://ftp.graphicsmagick.org/pub/GraphicsMagick/delegates/jpegsrc.v8d.tar.gz</p>
</li>
<li><p>编译安装 libjpeg</p>
<pre><code class="bash">tar -zxvf jpegsrc.v8d.tar.gz
<span class="hljs-built_in">cd</span> jpeg-<span class="hljs-number">8</span>d
./configure
make &amp;&amp; make install</code></pre>
</li>
<li><p>将 libjpeg 添加到 /usr/lib64 中<br>默认编译安装的位置是 <code>/usr/local/lib</code>，但 gm 会检查 <code>/usr/lib64</code> 位置的 libjpeg，所以创建一个软链接。</p>
<pre><code class="bash"><span class="hljs-built_in">cd</span> /usr/lib64
ln <span class="hljs-operator">-s</span> /usr/<span class="hljs-built_in">local</span>/lib/libjpeg.so.<span class="hljs-number">8.4</span>.<span class="hljs-number">0</span> libjpeg.so.<span class="hljs-number">8</span></code></pre>
</li>
<li><p>下载和编译安装 GraphicsMagick<br>可以选择 GraphicsMagick 1.3.20，编译安装的方式与步骤 4 类似。<br>安装好后，运行 <code>gm version</code> 查看版本。</p>
</li>
</ol>
<h1>运行不了 gm？</h1>
<p>如果输入上述代码显示 <code>command not found</code> 的话，可以手动地在安装包中找出 gm 文件，并复制到 <code>/usr/local/lib</code> 中。参考命令：</p>
<pre><code class="bash">find . -name <span class="hljs-string">'gm'</span>
cp [SOURCE_LOCATION] /usr/<span class="hljs-built_in">local</span>/lib/gm</code></pre>
]]></description><pubDate>Thu Apr 23 2015 08:00:00 GMT+0800 (CST)</pubDate><link>http://edwardchu.org/articles/wrong-jpeg-library-version.html</link><guid isPermaLink="true">http://edwardchu.org/articles/wrong-jpeg-library-version.html</guid></item><item><title>如何编写一个 Brackets 插件</title><description><![CDATA[<p><a href="http://brackets.io/" title="Brackets - A modern, open source code editor that understands web design.">Adobe Brackets</a> 是一个现代的 Web 开发编辑器，拥有着众多插件和粉丝。<br>Brackets 虽说由 Adobe 开发，但它却是开源且免费的。其开发语言为 JavaScript，因此迭代非常迅速。<br>虽说 Brackets 插件众多，却有一款至今找不着，所以便有了今天这篇文章。<br><!-- more --></p>
<h2>从 Sublime 到 Brackets</h2>
<p>之前我一直在用 <a href="http://www.sublimetext.com/">Sublime Text</a>，它有着更多优秀的插件。但其实 Sublime 本身可定制的地方并不多，这很大程度上影响了插件功能的拓展。其次它并不针对于 Web 开发，所以当起 Web IDE 的角色来，还是比 Brackets 更逊色一些。要说最糟糕的是，Sublime 的更新已几乎停滞，与 Brackets 的「每月至少一个新特性」形成鲜明的对比。<br>因此我这次把 Brackets 从软件堆里拿出来，再对它审视了一番。发现插件比以前更丰富了，而且有些功能还蛮赞的。<br>只可惜 Brackets 的 Snippets 功能不如 Sublime 的强大，所以我写了一个插件来增强它（叫 <code>Brackets Snippets</code>，源码在 <a href="https://github.com/chuyik/brackets-snippets">Github</a>）。<br>而下面的入门教程，主要是基于这个插件（代码结构基本一致）。</p>
<h2>写一个简单插件</h2>
<p>我们先从一个简单的插件入手，了解一些基本信息。</p>
<h3>本地创建一些文件</h3>
<p>首先打开 Brackets，点击菜单的 <code>Help &gt; Show Extensions Folder</code>，打开插件所在的目录。进入 <code>user</code> 子目录，创建一个新文件夹，叫 <code>hello-my-world</code>，然后创建两个文件，分别名为 <code>main.js</code> 和 <code>package.json</code>。注意文件名是固定的。</p>
<p><code>main.js</code>: 插件启动时运行的代码文件<br><code>package.json</code>: 插件的元信息</p>
<p>最终文件结构如下：</p>
<pre class="tree">
├── hello-my-world/
│   ├── main.js
│   ├── package.json
</pre>

<h3>package.json 基本结构</h3>
<p>这个文件保存的是插件的元信息，包括插件名称、描述、作者信息、协议等。<br>内容如下：</p>
<pre><code class="json">{
  "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">"hello-my-world"</span></span>,
  "<span class="hljs-attribute">title</span>": <span class="hljs-value"><span class="hljs-string">"Hello My World"</span></span>,
  "<span class="hljs-attribute">description</span>": <span class="hljs-value"><span class="hljs-string">"My first brackets extension, impressive!"</span></span>,
  "<span class="hljs-attribute">homepage</span>": <span class="hljs-value"><span class="hljs-string">"https://github.com/yourname/yourproject"</span></span>,
  "<span class="hljs-attribute">version</span>": <span class="hljs-value"><span class="hljs-string">"1.0.0"</span></span>,
  "<span class="hljs-attribute">author</span>": <span class="hljs-value"><span class="hljs-string">"Your Name &lt;your@email&gt; (http://your.url)"</span></span>,
  "<span class="hljs-attribute">license</span>": <span class="hljs-value"><span class="hljs-string">"MIT"</span></span>,
  "<span class="hljs-attribute">engines</span>": <span class="hljs-value">{
  "<span class="hljs-attribute">brackets</span>": <span class="hljs-value"><span class="hljs-string">"&gt;=0.24.0"</span>
  </span>}
</span>}</code></pre>
<p>其中必填的字段为 <code>name</code> 和 <code>version</code>，详细规则见 <a href="https://github.com/adobe/brackets/wiki/Extension-package-format#packagejson-format" title="Extension package format">Extension package format</a>。</p>
<h3>main.js 基本结构</h3>
<p>这个文件在 Brackets 启动时会被自动加载，是插件运行的入口。<br>它的基本结构为：</p>
<pre><code class="javascript"><span class="hljs-comment">/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */</span>
<span class="hljs-comment">/*global define, $, brackets, window, Mustache */</span>

define(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(require, exports, module)</span> </span>{
<span class="hljs-pi">  "use strict"</span>;
  <span class="hljs-keyword">var</span> AppInit = brackets.getModule(<span class="hljs-string">"utils/AppInit"</span>);

  <span class="hljs-comment">// Brackets 初始化完成</span>
  AppInit.appReady(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Brackets 启动完毕后运行的代码</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello World'</span>);
    <span class="hljs-built_in">window</span>.alert(<span class="hljs-string">'Hello My World'</span>);
  });
});</code></pre>
<blockquote>
<p>全局变量</p>
<p>从上面的代码可以看出，我们有几个全局变量可以使用，分别是：<br><code>define</code>: 表示定义一个插件模块，来源于 <a href="http://requirejs.org/" title="RequireJS">RequireJS</a><br><code>$</code>: jQuery 对象，用于操纵 DOM 元素<br><code>brackets</code>: 用来访问软件中的其他模块，软件运行环境（系统语言、系统平台），软件版本等信息<br><code>window</code>: 浏览器全局对象<br><code>Mustache</code>: 模板语言，详细可以参考 <a href="https://github.com/janl/mustache.js">Mustache</a></p>
</blockquote>
<h3>运行插件</h3>
<p>编辑保存好 main.js 和 package.json 后，点击菜单的 <code>Debug &gt; Reload With Extensions</code>（CMD+R / CTRL+R）来重新加载 Brackets 以运行最新的代码，如果弹出了一个 &quot;Hello My World&quot; 的对话框，则测试成功。</p>
<h3>调试（Debug）插件</h3>
<p>点击菜单的 <code>Debug &gt; Show Developer Tools</code>，会弹出一个似曾相识的调试窗口。可以点击 <code>Sources</code> 选项卡进行断点调试，也可以点击 <code>Console</code> 选项卡直接运行些代码。<br>值得注意的是，当你第一次打开调试窗口，请务必点击右上角的设置按钮，选中 <code>Disable cache (while DevTools is open)</code>，确保没有缓存的干扰。</p>
<h2>实现一个插入皮卡丘图形的插件</h2>
<p>了解基本的信息过后，我们可以尝试写一个插件，实现一个功能：<br>在文档某个位置插入皮卡丘的 ASCII 立体图。</p>
<blockquote>
<p><a href="http://zh.wikipedia.org/wiki/ASCII%E7%AB%8B%E4%BD%93%E5%9B%BE">ASCII 立体图</a></p>
<p>听到这个名字，或许会觉得陌生吧？<br>但其实这个东西在互联网上很常见啦，它是「火星文」、「颜文字」的鼻祖，主要通过字符排列引起视觉上的错觉。</p>
<p>喂喂下面这些字符你看破了嘛？</p>
<pre><code>  _|_|_|  _|    _|  _|_|_|    _|_|_|_|  _|_|_|
_|        _|    _|  _|    _|  _|        _|    _|
  _|_|    _|    _|  _|_|_|    _|_|_|    _|_|_|
      _|  _|    _|  _|        _|        _|    _|
_|_|_|      _|_|    _|        _|_|_|_|  _|    _|

_|      _|    _|_|    _|_|_|    _|_|_|    _|_|
_|_|  _|_|  _|    _|  _|    _|    _|    _|    _|
_|  _|  _|  _|_|_|_|  _|_|_|      _|    _|    _|
_|      _|  _|    _|  _|    _|    _|    _|    _|
_|      _|  _|    _|  _|    _|  _|_|_|    _|_|</code></pre>
</blockquote>
<p>这部分我们另起炉灶，创建一个新的插件，叫 <code>ascii-pokemon</code>。</p>
<p>目录结构如下：</p>
<pre class="tree">
├── ascii-pokemon/
│   ├── main.js
│   ├── package.json
│   ├── pikachu.txt
</pre>

<h3>package.json</h3>
<p>这里提供一些必要字段，其他字段可以参考前面的介绍。</p>
<pre><code class="json">{
  "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">"ascii-pokemon"</span></span>,
  "<span class="hljs-attribute">title</span>": <span class="hljs-value"><span class="hljs-string">"ASCII Pokemon"</span></span>,
  "<span class="hljs-attribute">version</span>": <span class="hljs-value"><span class="hljs-string">"1.0.0"</span>
</span>}</code></pre>
<h3>pikachu.txt</h3>
<p><code>pikachu</code> 是什么东西？其实就是皮卡丘的英文名字啦！<br>我们利用这个文件，存储皮卡丘的图形。<br>把下面这个复制进去（来源于<a href="http://www.fiikus.net/?pokedex">这个网站</a>，有第一代的所有宠物）：</p>
<pre><code>                                             ,-.
                                          _.|  &#39;
                                        .&#39;  | /
                                      ,&#39;    |&#39;
                                     /      /
                       _..----&quot;&quot;---.&#39;      /
 _.....---------...,-&quot;&quot;                  ,&#39;
 `-._  \                                /
     `-.+_            __           ,--. .
          `-.._     .:  ).        (`--&quot;| \
               7    | `&quot; |         `...&#39;  \
               |     `--&#39;     &#39;+&quot;        ,&quot;. ,&quot;&quot;-
               |   _...        .____     | |/    &#39;
          _.   |  .    `.  &#39;--&quot;   /      `./     j
         \&#39; `-.|  &#39;     |   `.   /        /     /
         &#39;     `-. `---&quot;      `-&quot;        /     /
          \       `.                  _,&#39;     /
           \        `                        .
            \                                j
             \                              /
              `.                           .
                +                          \
                |                           L
                |                           |
                |  _ /,                     |
                | | L)&#39;..                   |
                | .    | `                  |
                &#39;  \&#39;   L                   &#39;
                 \  \   |                  j
                  `. `__&#39;                 /
                _,.--.---........__      /
               ---.,&#39;---`         |   -j&quot;
                .-&#39;  &#39;....__      L    |
              &quot;&quot;--..    _,-&#39;       \ l||
                  ,-&#39;  .....------. `||&#39;
               _,&#39;                /
             ,&#39;                  /
            &#39;---------+-        /
                     /         /
                   .&#39;         /
                 .&#39;          /
               ,&#39;           /
             _&#39;....----&quot;&quot;&quot;&quot;&quot; mh</code></pre>
<h3>读取外部静态文档</h3>
<p>如果想在代码中读取一些 <code>json</code> 或者 <code>txt</code> 文档的内容，就可以使用 <code>require</code> 方法。<br>由于内置的第三方依赖管理工具是 <code>RequireJS</code>，所以在读取文本的时候，要在路径前加上 <code>text!</code> 的前缀。</p>
<p>使用 <code>require</code> 读取静态文档内容：</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> pikachu = <span class="hljs-built_in">require</span>(<span class="hljs-string">'text!pikachu.txt'</span>);</code></pre>
<p>整合前面提及的 <code>main.js</code> 基本结构后，最新的代码为：</p>
<pre><code class="javascript"><span class="hljs-comment">/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */</span>
<span class="hljs-comment">/*global define, $, brackets, window, Mustache */</span>

define(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(require, exports, module)</span> </span>{
<span class="hljs-pi">  "use strict"</span>;

  <span class="hljs-keyword">var</span> AppInit  = brackets.getModule(<span class="hljs-string">'utils/AppInit'</span>),
      pikachu  = <span class="hljs-built_in">require</span>(<span class="hljs-string">'text!pikachu.txt'</span>);

  AppInit.appReady(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">console</span>.log(pikachu);
  });
});</code></pre>
<p>保存完后，打开调试窗口，重新加载一下 Brackets（CMD+R / CTRL+R），就会看到调试窗口中出现了皮卡丘可爱的身影。<br>只可惜如果想再召唤出皮卡丘，就只能再加载一次 Brackets。这未免太坑爹了吧？<br>为了可以无限使用精灵球，我们可以把「召唤」这个命令写进菜单里，这样就可以随召随到啦！<br>为了达到这个目的，我们来了解下 Brackets 的菜单。</p>
<h3>添加菜单命令</h3>
<p>Brackets 菜单模块叫做 <code>Menus</code>，可以通过 <code>brackets.getModule(&quot;command/Menus&quot;)</code> 获得。<br>菜单对象分为「菜单栏的菜单 Menu」和「右键菜单 ContextMenu」，每个对象都有一个固定的 ID。</p>
<p>菜单栏上可以看到有 <code>File/Edit/...</code> 等菜单对象，它们的 ID 分别是：</p>
<blockquote>
<ul>
<li>File <code>FILE_MENU</code></li>
<li>Edit <code>EDIT_MENU</code></li>
<li>Find <code>FIND_MENU</code></li>
<li>View <code>VIEW_MENU</code></li>
<li>Navigate <code>NAVIGATE_MENU</code></li>
<li>Help <code>HELP_MENU</code></li>
</ul>
</blockquote>
<p>而右键菜单主要根据点击的区域而不同，这些区域和菜单对象 ID 分别是：</p>
<blockquote>
<ul>
<li>文本编辑区域 <code>EDITOR_MENU</code></li>
<li>行内编辑区域 <code>INLINE_EDITOR_MENU</code>（即点击 <code>Quick Edit</code> 后出现的编辑区域）</li>
<li>文件目录树区域 <code>PROJECT_MENU</code></li>
<li>已打开的文件区域 <code>WORKING_SET_CONTEXT_MENU</code>（即「文件目录树」上方区域）</li>
<li>点击排序按钮出现的菜单 <code>WORKING_SET_CONFIG_MENU</code>（即「已打开的文件区域」右上角按钮）</li>
<li>点击分割视图按钮出现的菜单 <code>SPLITVIEW_MENU</code>（即「已打开的文件区域」右上角按钮）</li>
</ul>
</blockquote>
<p>若想要完成「添加自定义菜单，点击菜单时完成某个指令」的操作，需要调用以下三个方法：</p>
<blockquote>
<ol>
<li><a href="http://brackets.io/docs/current/modules/command/CommandManager.html#-register">CommandManager.register(name, id, commandFn)</a> 注册某个指令，以便于和菜单进行绑定。</li>
<li><a href="http://brackets.io/docs/current/modules/command/Menus.html#-getMenu">Menus.getMenu(menuId)</a> 提供上面提到的菜单 ID，获取相对应的菜单对象。</li>
<li><a href="http://brackets.io/docs/current/modules/command/Menus.html#Menu-addMenuItem">menu.addMenuItem(commandID, keyBindings)</a> 将已注册的指令 ID 添加到某个菜单对象去。</li>
</ol>
</blockquote>
<p>具体实现的代码：</p>
<pre><code class="javascript"><span class="hljs-comment">/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */</span>
<span class="hljs-comment">/*global define, $, brackets, window, Mustache */</span>

define(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(require, exports, module)</span> </span>{
<span class="hljs-pi">  "use strict"</span>;

  <span class="hljs-keyword">var</span> AppInit        = brackets.getModule(<span class="hljs-string">'utils/AppInit'</span>),
      CommandManager = brackets.getModule(<span class="hljs-string">"command/CommandManager"</span>),
      Menus          = brackets.getModule(<span class="hljs-string">"command/Menus"</span>),
      pikachu        = <span class="hljs-built_in">require</span>(<span class="hljs-string">'text!pikachu.txt'</span>);

  <span class="hljs-comment">// 菜单点击时执行的函数</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commandHandler</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">console</span>.log(pikachu);
  }

  <span class="hljs-comment">// 命令 ID（注意要唯一）</span>
  <span class="hljs-keyword">var</span> COMMAND_ID = <span class="hljs-string">"ascii-pokemon.pikachu"</span>;
  <span class="hljs-comment">// 注册命令（提供三个参数，分别为：用于显示的命令名称、命令 ID、回调函数）</span>
  CommandManager.register(<span class="hljs-string">"召唤皮卡丘"</span>, COMMAND_ID, commandHandler);

  <span class="hljs-comment">// `Edit` 菜单对象</span>
  <span class="hljs-keyword">var</span> menu = Menus.getMenu(Menus.AppMenuBar.EDIT_MENU);
  <span class="hljs-comment">// 文本编辑区域的右键菜单对象</span>
  <span class="hljs-keyword">var</span> contextMenu = Menus.getContextMenu(Menus.ContextMenuIds.EDITOR_MENU);

  <span class="hljs-comment">// 把命令添加到菜单去</span>
  menu.addMenuItem(COMMAND_ID);
  contextMenu.addMenuItem(COMMAND_ID);

  AppInit.appReady(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 留空</span>
  });
});</code></pre>
<p>保存文件之后，需要重新加载 Brackets。加载完毕后，你会发现 <code>Edit</code> 菜单和编辑区域的右键菜单多了一个中文命令。点击一下它，再看看调试窗口是否成功。<br>但目前为止，皮卡丘还只是活在调试窗口中耶。这样不行了啦，我们还想要把它带到 Brackets 的核心，那就是文档编辑区域。<br>下面我们来看看来了解一下通过操作 <code>Editor</code> 和 <code>Document</code> 的实例，实现这个目的。</p>
<h3>编辑当前文档</h3>
<p>Brackets 每个已打开的文档都是一个对象，均为 <code>Document</code> 的子类。<br>而每个文档所对应的编辑器，就是 <code>Editor</code>，与 <code>Document</code> 为一对一的关系。</p>
<p>获取 <code>Editor</code> 对象的几种方法：</p>
<blockquote>
<ul>
<li><code>EditorManager.getFocusedEditor()</code> 返回当前获得焦点的编辑器对象</li>
<li><code>EditorManager.getActiveEditor()</code> 返回当前正在编辑的编辑器对象。和上面的方法相似，区别在于如果当前焦点被转移到了搜索栏、对话框等地方，就会返回最后一个获得焦点的编辑器对象</li>
<li><code>EditorManager.getCurrentFullEditor()</code> 返回当前打开的文本的编辑器对象，不包括行内编辑器（Inline Editor，即通过 <code>Quick Edit</code> 打开的编辑器）</li>
</ul>
</blockquote>
<p>获得 <code>Editor</code> 对象之后，<code>Document</code> 对象就垂手可得了：</p>
<pre><code class="javascript">  <span class="hljs-keyword">var</span> <span class="hljs-built_in">document</span> = editor.document;</code></pre>
<p>下面要介绍的是 <code>Editor</code> 和 <code>Document</code> 一些常用的方法。</p>
<p><strong>Editor 对象</strong></p>
<blockquote>
<ul>
<li><a href="http://brackets.io/docs/current/modules/editor/Editor.html#Editor-getCursorPos">getCursorPos()</a> 返回光标的位置。注意位置的格式为：<code>{line:number, ch:number}</code>，下同</li>
<li><a href="http://brackets.io/docs/current/modules/editor/Editor.html#Editor-getSelectedText">getSelectedText()</a> 返回当前被选中的内容</li>
<li><a href="http://brackets.io/docs/current/modules/editor/Editor.html#Editor-setSelection">setSelection(start, end)</a> 选中某个范围的内容</li>
<li><a href="http://brackets.io/docs/current/modules/editor/Editor.html#Editor-selectWordAt">selectWordAt(position)</a> 选中某个位置上的单词</li>
</ul>
</blockquote>
<p><strong>Document 对象</strong></p>
<blockquote>
<ul>
<li><a href="http://brackets.io/docs/current/modules/document/Document.html#Document-getText">getText()</a> 返回当前文本的所有内容，包括未保存的部分</li>
<li><a href="http://brackets.io/docs/current/modules/document/Document.html#Document-setText">setText(text)</a> 替换当前文本的所有内容</li>
<li><a href="http://brackets.io/docs/current/modules/document/Document.html#Document-getLine">getLine(number)</a> 返回某行的文本内容</li>
<li><a href="http://brackets.io/docs/current/modules/document/Document.html#Document-getRange">getRange(start, end)</a> 返回某个范围的所有内容</li>
<li><a href="http://brackets.io/docs/current/modules/document/Document.html#Document-replaceRange">replaceRange(text, start, end)</a> 替换某个范围的所有内容</li>
</ul>
</blockquote>
<p>结合上面一些 API 提供的方法，我们实现一个功能：「在文档光标所在的位置召唤出皮卡丘」。</p>
<p>具体代码如下：</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> EditorManager  = brackets.getModule(<span class="hljs-string">"editor/EditorManager"</span>);

<span class="hljs-comment">// 菜单点击时执行的函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commandHandler</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// 获取当前打开的文本的编辑器对象</span>
  <span class="hljs-keyword">var</span> editor = EditorManager.getCurrentFullEditor();

  <span class="hljs-keyword">if</span> (editor) {
    <span class="hljs-comment">// 获取光标位置，格式为：CodeMirror.Pos {line: 16, ch: 7}</span>
    <span class="hljs-keyword">var</span> insertionPos = editor.getCursorPos();

    <span class="hljs-comment">// 在光标后面插入皮卡丘图形</span>
    editor.document.replaceRange(pikachu, insertionPos);
  }
}</code></pre>
<p>将上面的代码与原来的合并之后，重新加载 Brackets，将光标放在文档的任意位置，点击右键「召唤皮卡丘」，是不是就出来了？<br>好了，目前为止我们已经获得了不错的效果，但是好像通过点击菜单的方式还是有点麻烦。<br>对于程序员而言，假如我们敲击咒语 <code>pikapika</code>，再按下 <code>Tab</code> 键，皮卡丘就出来了岂不是更爽？<br>因此接下来，让我们一起了解下 Brackets 的事件机制。</p>
<h3>Brackets 事件</h3>
<p>Brackets 主要利用 jQuery 来进行事件的分发。了解 jQuery 的同学都知道其绑定事件和解绑事件的方法分别是 <code>$(obj).on()</code> 和 <code>$(obj).off()</code>，Brackets 中同样如此。</p>
<p>下面介绍 <code>Editor</code> 对象中支持的事件：</p>
<blockquote>
<ul>
<li><code>keydown, keypress, keyup</code> 当任意按键按下时，会触发这几个事件。回调函数接收 <code>(BracketsEvent, Editor, KeyboardEvent)</code> 参数</li>
<li><code>cursorActivity</code> 当用户移动光标、选中的字符有变动、有修改操作，均会触发此事件。注意由于这个事件威力太猛，所以不建议监听，但可以换成 <code>$(editor.document).on(&#39;change&#39;, changeHandler)</code></li>
<li><code>scroll</code> 当编辑器有滚动的操作触发</li>
<li><code>lostContent</code> 当文档内容丢失时触发</li>
<li><code>optionChange</code> 当因选项变动导致编辑器发生改变时触发</li>
<li><code>beforeDestroy</code> 当编辑器对象被销毁时触发</li>
</ul>
</blockquote>
<p>对于监听键盘敲击事件而言，我们常用 <code>keypress</code> 事件。但如果涉及到功能键（如 Tab/Ctrl/Shift）的话，则要改用 <code>keydown</code> 事件。因此这里我们选择监听后者。</p>
<p>具体代码如下：</p>
<pre><code class="javascript">  <span class="hljs-keyword">var</span> EditorManager = brackets.getModule(<span class="hljs-string">"editor/EditorManager"</span>);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">keyHandler</span> <span class="hljs-params">(bracketsEvent, editor, keyboardEvent)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'keycode: '</span>, keyboardEvent.keyCode);
  }

  AppInit.appReady(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> editor = EditorManager.getCurrentFullEditor();
    $(editor).on(<span class="hljs-string">"keydown"</span>, keyHandler);
  });</code></pre>
<p>然而当你整合完代码后会发现，代码好像并没有执行，或者说切换另一个文档的时候，代码就失效了。<br>为了确保代码始终对当前文档有效，我们还要再监听 <code>EditorManager</code> 的 <code>activeEditorChange</code> 事件。</p>
<p>具体代码如下：</p>
<pre><code class="javascript">  <span class="hljs-keyword">var</span> EditorManager  = brackets.getModule(<span class="hljs-string">"editor/EditorManager"</span>);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">keyHandler</span> <span class="hljs-params">(bracketsEvent, editor, keyboardEvent)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'keycode: '</span>, keyboardEvent.keyCode);
  }

  <span class="hljs-comment">// 文档切换时重新绑定监听事件</span>
  <span class="hljs-keyword">var</span> activeEditorChangeHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(bracketsEvent, focusedEditor, lostEditor)</span> </span>{
    <span class="hljs-keyword">if</span> (lostEditor) {
      $(lostEditor).off(<span class="hljs-string">"keydown"</span>, keyHandler);
    }

    <span class="hljs-keyword">if</span> (focusedEditor) {
      $(focusedEditor).on(<span class="hljs-string">"keydown"</span>, keyHandler);
    }
  };

  AppInit.appReady(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 绑定文档切换事件</span>
    $(EditorManager).on(<span class="hljs-string">'activeEditorChange'</span>, activeEditorChangeHandler);
  });</code></pre>
<p>目前我们已经了解了 <code>Editor</code> 对象的一些方法和它的监听事件。因此我们很容易地实现最后一个功能：「敲击咒语 <code>pikapika</code>，再按下 <code>Tab</code> 键，召唤出皮卡丘」。</p>
<p>具体实现代码：</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> KeyEvent = brackets.getModule(<span class="hljs-string">"utils/KeyEvent"</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">keyHandler</span> <span class="hljs-params">(bracketsEvent, editor, keyboardEvent)</span> </span>{

  <span class="hljs-comment">// 如果用户按键不是 Tab 键，返回</span>
  <span class="hljs-keyword">if</span> (keyboardEvent.keyCode !== KeyEvent.DOM_VK_TAB) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 获取当前光标位置</span>
  <span class="hljs-keyword">var</span> cursorPos = editor.getCursorPos();

  <span class="hljs-comment">// 获取当前行的所有文字</span>
  <span class="hljs-keyword">var</span> lineStr = editor.document.getLine(cursorPos.line);

  <span class="hljs-comment">// 咒语</span>
  <span class="hljs-keyword">var</span> mantra = <span class="hljs-string">'pikapika'</span>;

  <span class="hljs-comment">// 判断光标前的字符与咒语是否一致</span>
  <span class="hljs-keyword">if</span> (mantra === lineStr.substr(cursorPos.ch - mantra.length, cursorPos.ch)) {
    <span class="hljs-keyword">var</span> start = {
        line: cursorPos.line,
        ch: cursorPos.ch - mantra.length
    };
    <span class="hljs-comment">// 在光标后面插入皮卡丘图形</span>
    editor.document.replaceRange(pikachu, start, cursorPos);
  }
}</code></pre>
<p>整合前面提及的所有东西，<strong>最终完整的代码</strong>如下：</p>
<pre><code class="javascript"><span class="hljs-comment">/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */</span>
<span class="hljs-comment">/*global define, $, brackets, window, Mustache */</span>

define(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(require, exports, module)</span> </span>{
<span class="hljs-pi">  "use strict"</span>;

  <span class="hljs-keyword">var</span> AppInit        = brackets.getModule(<span class="hljs-string">'utils/AppInit'</span>),
      CommandManager = brackets.getModule(<span class="hljs-string">"command/CommandManager"</span>),
      EditorManager  = brackets.getModule(<span class="hljs-string">"editor/EditorManager"</span>),
      Menus          = brackets.getModule(<span class="hljs-string">"command/Menus"</span>),
      KeyEvent       = brackets.getModule(<span class="hljs-string">"utils/KeyEvent"</span>),
      pikachu        = <span class="hljs-built_in">require</span>(<span class="hljs-string">'text!pikachu.txt'</span>);

  <span class="hljs-comment">// 菜单点击时执行的函数</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commandHandler</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 获取当前打开的文本的编辑器对象</span>
    <span class="hljs-keyword">var</span> editor = EditorManager.getCurrentFullEditor();

    <span class="hljs-keyword">if</span> (editor) {
      <span class="hljs-comment">// 获取光标位置，格式为：CodeMirror.Pos {line: 16, ch: 7}</span>
      <span class="hljs-keyword">var</span> insertionPos = editor.getCursorPos();

      <span class="hljs-comment">// 在光标后面插入皮卡丘图形</span>
      editor.document.replaceRange(pikachu, insertionPos);
    }
  }

  <span class="hljs-comment">// 命令 ID（注意要唯一）</span>
  <span class="hljs-keyword">var</span> COMMAND_ID = <span class="hljs-string">"ascii-pokemon.pikachu"</span>;
  <span class="hljs-comment">// 注册命令（提供三个参数，分别为：用于显示的命令名称、命令 ID、回调函数）</span>
  CommandManager.register(<span class="hljs-string">"召唤皮卡丘"</span>, COMMAND_ID, commandHandler);

  <span class="hljs-comment">// `Edit` 菜单对象</span>
  <span class="hljs-keyword">var</span> menu = Menus.getMenu(Menus.AppMenuBar.EDIT_MENU);
  <span class="hljs-comment">// 文本编辑区域的右键菜单对象</span>
  <span class="hljs-keyword">var</span> contextMenu = Menus.getContextMenu(Menus.ContextMenuIds.EDITOR_MENU);

  <span class="hljs-comment">// 把命令添加到菜单去</span>
  menu.addMenuItem(COMMAND_ID);
  contextMenu.addMenuItem(COMMAND_ID);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">keyHandler</span> <span class="hljs-params">(bracketsEvent, editor, keyboardEvent)</span> </span>{

    <span class="hljs-comment">// 如果用户按键不是 Tab 键，返回</span>
    <span class="hljs-keyword">if</span> (keyboardEvent.keyCode !== KeyEvent.DOM_VK_TAB) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 获取当前光标位置</span>
    <span class="hljs-keyword">var</span> cursorPos = editor.getCursorPos();

    <span class="hljs-comment">// 获取当前行的所有文字</span>
    <span class="hljs-keyword">var</span> lineStr = editor.document.getLine(cursorPos.line);

    <span class="hljs-comment">// 咒语</span>
    <span class="hljs-keyword">var</span> mantra = <span class="hljs-string">'pikapika'</span>;

    <span class="hljs-comment">// 判断光标前的字符与咒语是否一致</span>
    <span class="hljs-keyword">if</span> (mantra === lineStr.substr(cursorPos.ch - mantra.length, cursorPos.ch)) {
      <span class="hljs-keyword">var</span> start = {
          line: cursorPos.line,
          ch: cursorPos.ch - mantra.length
      };
      <span class="hljs-comment">// 在光标后面插入皮卡丘图形</span>
      editor.document.replaceRange(pikachu, start, cursorPos);
    }
  }

  <span class="hljs-comment">// 切换文件编辑窗口，重新绑定按键监听事件</span>
  <span class="hljs-keyword">var</span> activeEditorChangeHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(bracketsEvent, focusedEditor, lostEditor)</span> </span>{
    <span class="hljs-keyword">if</span> (lostEditor) {
      $(lostEditor).off(<span class="hljs-string">"keydown"</span>, keyHandler);
    }

    <span class="hljs-keyword">if</span> (focusedEditor) {
      $(focusedEditor).on(<span class="hljs-string">"keydown"</span>, keyHandler);
    }
  };

  AppInit.appReady(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 绑定文档切换事件</span>
    $(EditorManager).on(<span class="hljs-string">'activeEditorChange'</span>, activeEditorChangeHandler);
  });
});</code></pre>
<p>好了，如果你看到了这里，说明你已经掌握了如何制作一个 Brackets 插件。<br>接下来，你可以尝试查看其他插件的源码，甚至是 Brackets 的源码进行学习。<br>下面是一些开发的相关链接，希望能给你带来更多的帮助。</p>
<h2>相关链接</h2>
<p><a href="http://brackets.io/docs/current/modules/editor/Editor.html">Brackets API</a><br><a href="https://github.com/adobe/brackets/wiki">Brackets Wiki</a><br><a href="https://groups.google.com/forum/?hl=en#!forum/brackets-dev">Brackets 开发论坛</a><br><a href="http://codemirror.net/">CodeMirror - Brackets Editor 核心</a></p>
<h2>参考文章 Credits</h2>
<p><a href="https://github.com/adobe/brackets/wiki/How-to-write-extensions">How to write extensions · adobe/brackets Wiki</a><br><a href="http://artoale.com/tutorial/brackets/2013/10/04/writing-brackets-extension-02/">Writing Brackets extension - part 2</a><br><a href="http://www.adobe.com/cn/devnet/edge-code/articles/building-your-first-brackets-extension.html">构建首个 Brackets 扩展 | Adobe 开发人员连接</a></p>
]]></description><pubDate>Wed Jan 07 2015 08:00:00 GMT+0800 (CST)</pubDate><link>http://edwardchu.org/articles/how-to-write-brackets-extension.html</link><guid isPermaLink="true">http://edwardchu.org/articles/how-to-write-brackets-extension.html</guid></item><item><title>PouchDB 全面介绍</title><description><![CDATA[<p><a href="http://pouchdb.com/">PouchDB</a> 是一个能运行在网页上、支持数据同步、专为移动应用设计的 NoSQL 数据库。<br>本文将从多个方面介绍 PouchDB，包括如何上手，如何同步、解决同步带来的数据冲突，如何与 AngularJS 结合、在 Cordova/Phonegap 上运用，局限性以及服务器的设置。<br><!-- more --></p>
<h2>PouchDB 的优点</h2>
<ol>
<li><p>数据双向同步</p>
<blockquote>
<p>网页、手机客户端在离线后生成的数据，可以在上线时被同步至服务器<br>服务端生成或接收到数据后，可以实时推送给其他的客户端</p>
</blockquote>
</li>
<li><p>数据支持版本管理</p>
<blockquote>
<p>由于同步会带来很多的数据冲突的问题，所以 PouchDB 仿照了 Git（代码版本管理工具），将每份数据打上了版本号，便于数据的回溯和还原。</p>
</blockquote>
</li>
<li><p>专为 Web 而生</p>
<blockquote>
<p>使用 HTTP 协议和 RESTful 格式进行数据查看与操作<br>PouchDB 用 JavaScript 写成，能方便地运行在网页、Hybird App、NodeJS 上</p>
</blockquote>
</li>
<li><p>轻量级和完善的官方文档</p>
</li>
<li><p>开源项目（Apache 协议）</p>
</li>
</ol>
<h2>PouchDB 入门</h2>
<h2>PouchDB 同步</h2>
<h2>PouchDB 与 AngularJS 的结合</h2>
<h2>在 Cordova 上使用 PouchDB</h2>
<h2>PouchDB 使用限制</h2>
<h2>PouchDB 与 CouchDB 的关系</h2>
<h2>参考文章 Credits</h2>
<p><a href="http://www.mircozeiss.com/sync-multiple-angularjs-apps-without-server-via-pouchdb/">http://www.mircozeiss.com/sync-multiple-angularjs-apps-without-server-via-pouchdb/</a></p>
]]></description><pubDate>Wed Jan 07 2015 08:00:00 GMT+0800 (CST)</pubDate><link>http://edwardchu.org/articles/pouchdb-intro.html</link><guid isPermaLink="true">http://edwardchu.org/articles/pouchdb-intro.html</guid></item><item><title>用 Docker 构建 NodeJS 应用</title><description><![CDATA[<p><a href="http://www.docker.com/">Docker</a> 是个轻量级的虚拟化解决方案，可以将你的应用和所需的运行环境打包起来，部署至其他环境，保证开发或生产环境的统一。<br>对于开发人员来说，Docker 可以减少初次搭建开发环境的麻烦；<br>对于运维人员来说，Docker 使自动化、规模化部署变得更加简单。<br><!-- more --></p>
<h2>Docker 入门</h2>
<p>本文不涉及太多的入门知识，假若你未曾听过 Docker，请先浏览官方资源：<br>1. 观看 Docker <a href="https://www.docker.com/whatisdocker/">介绍视频</a><br>2. 动手完成 10 分钟 <a href="https://www.docker.com/tryit/#">在线交互教程</a></p>
<h2>下载并更新 Ubuntu 镜像</h2>
<p>本文中 NodeJS 应用是部署在 Ubuntu 下的，所以要先通过以下命令，下载 Ubuntu 镜像，并更新保存。</p>
<pre><code class="bash"><span class="hljs-comment"># 从 Docker Hub 下载官方维护的 Ubuntu</span>
docker pull ubuntu:<span class="hljs-number">14.10</span>

<span class="hljs-comment"># 下载完毕后，先更新软件源</span>
docker run ubuntu:<span class="hljs-number">14.10</span> apt-get update

<span class="hljs-comment"># 上面命令会生成一个container，先获得其 id</span>
<span class="hljs-comment"># -l：显示最新的 container</span>
doocker ps <span class="hljs-operator">-l</span>

<span class="hljs-comment"># 提交改动，并覆盖原有的 Ubuntu 镜像</span>
docker commit &lt;container_id&gt; ubuntu:<span class="hljs-number">14.10</span></code></pre>
<h2>从创建简单的 NodeJS 应用镜像入手</h2>
<p>我们先来创建一个基于 ExpressJS 的简单 NodeJS 应用，以下是文件目录结构和步骤。</p>
<h3>目录结构</h3>
<pre class="tree">
├── docker-node-hello/
│   ├── index.js
│   ├── package.json
│   ├── Dockerfile
</pre>

<h3>文件创建步骤</h3>
<ol>
<li><p>创建文件夹</p>
<pre><code class="bash">mkdir ~/docker-node-hello &amp;&amp; <span class="hljs-built_in">cd</span> <span class="hljs-variable">$_</span></code></pre>
</li>
<li><p>创建 index.js</p>
<pre><code class="js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)
<span class="hljs-keyword">var</span> app = express()

app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, res)</span> </span>{
 res.send(<span class="hljs-string">'Hello World!'</span>)
})

<span class="hljs-keyword">var</span> server = app.listen(<span class="hljs-number">3001</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{

 <span class="hljs-keyword">var</span> host = server.address().address
 <span class="hljs-keyword">var</span> port = server.address().port

 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Example app listening at http://%s:%s'</span>, host, port)

})</code></pre>
</li>
<li><p>创建 package.json</p>
<pre><code class="json">{
 "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">"docker-node-hello"</span></span>,
 "<span class="hljs-attribute">private</span>": <span class="hljs-value"><span class="hljs-literal">true</span></span>,
 "<span class="hljs-attribute">version</span>": <span class="hljs-value"><span class="hljs-string">"0.0.1"</span></span>,
 "<span class="hljs-attribute">description</span>": <span class="hljs-value"><span class="hljs-string">"Node.js Hello world app on Ubuntu using docker"</span></span>,
 "<span class="hljs-attribute">dependencies</span>": <span class="hljs-value">{
   "<span class="hljs-attribute">express</span>": <span class="hljs-value"><span class="hljs-string">"4.x.x"</span>
 </span>}
</span>}</code></pre>
</li>
<li><p>创建 Dockerfile 配置文件</p>
<pre><code class="bash"><span class="hljs-comment"># 设置基础镜像</span>
FROM ubuntu:<span class="hljs-number">14.10</span>

<span class="hljs-comment"># 如果上个步骤已经更新软件源，这步可以忽略</span>
RUN apt-get update

<span class="hljs-comment"># 安装 NodeJS 和 npm</span>
RUN apt-get install -y nodejs npm

<span class="hljs-comment"># 将目录中的文件添加至镜像的 /srv/hello 目录中</span>
ADD . /srv/hello

<span class="hljs-comment"># 设置工作目录</span>
WORKDIR /srv/hello

<span class="hljs-comment"># 安装 Node 依赖库</span>
RUN npm install

<span class="hljs-comment"># 暴露 3001 端口，便于访问</span>
EXPOSE <span class="hljs-number">3001</span>

<span class="hljs-comment"># 设置启动时默认运行命令</span>
CMD [<span class="hljs-string">"nodejs”, “/srv/hello/index"</span>]</code></pre>
</li>
</ol>
<h3>构建镜像</h3>
<pre><code class="bash">  <span class="hljs-comment"># 通过该命令，按照 Dockerfile 所配置的信息构建出镜像</span>
  <span class="hljs-comment"># -t 镜像的名称</span>
  <span class="hljs-comment"># --rm 构建成功后，删除临时镜像（每执行一行 Dockerfile 中的命令，就会创建一个临时镜像）</span>
  docker build --rm -t node-hello .

  <span class="hljs-comment"># 检查镜像是否创建成功</span>
  docker images</code></pre>
<h3>运行镜像</h3>
<pre><code class="bash">  <span class="hljs-comment"># 对于 Mac 或 Windows 来说，要先查看 boot2docker 的 IP</span>
  boot2docker ip

  <span class="hljs-comment"># 运行刚刚创建的镜像</span>
  <span class="hljs-comment"># -p 设置端口，格式为「主机端口:容器端口」</span>
  docker run -p <span class="hljs-number">3001</span>:<span class="hljs-number">3001</span> node-hello</code></pre>
<h3>访问网页</h3>
<p>若终端打印出 <code>Example app listening at http://...</code>，则部署成功。<br>可以用浏览器访问 <code>http://&lt;boot2docker ip&gt;:3001</code>，或运行 <code>curl -s &quot;$(boot2docker ip):3001&quot;</code>。</p>
<h2>创建完整的 NodeJS 应用镜像（含 Mongodb / Git）</h2>
<p>通过上面的例子，我们知道了整个 Docker 镜像的基本创建过程。<br>但实际项目中，项目代码往往是通过 Git 来管理的，而且还会连接到一些数据库，如 Mongodb。<br>本例子中，我们将尝试部署一个 MEAN 架构的 NodeJS 应用。</p>
<blockquote>
<p>什么是 MEAN 架构？<br>MEAN 表示 Mongodb / ExpressJS / AngularJS / NodeJS，是目前流行的网站应用开发组合，涵盖前端至后台。由于这些框架用的语言都是 Javascript，所以又戏称 Javascript Fullstack。</p>
</blockquote>
<h3>目录结构</h3>
<pre class="tree">
├── docker-node-full/
│   ├── start.sh
│   ├── Dockerfile
</pre>

<h3>文件创建步骤</h3>
<ol>
<li><p>创建文件夹</p>
<pre><code class="bash">mkdir ~/docker-node-full &amp;&amp; <span class="hljs-built_in">cd</span> <span class="hljs-variable">$_</span></code></pre>
</li>
<li><p>创建 Dockerfile 配置文件</p>
<pre><code class="bash"><span class="hljs-comment"># 设置基础镜像</span>
FROM ubuntu:<span class="hljs-number">14.10</span>

<span class="hljs-comment"># 安装 NodeJS 和 npm</span>
RUN apt-get install -y nodejs npm

<span class="hljs-comment"># 由于 apt-get 下载的 Node 实际上是 nodejs，所以要创建一个 node 的快捷方式</span>
RUN ln <span class="hljs-operator">-s</span> /usr/bin/nodejs /usr/bin/node

<span class="hljs-comment"># 安装 Git</span>
RUN apt-get install -y git

<span class="hljs-comment"># 安装 Mongodb（来自官方教程）</span>
RUN apt-key adv --keyserver hkp://keyserver.ubuntu.com:<span class="hljs-number">80</span> --recv <span class="hljs-number">7</span>F0CEB10
RUN <span class="hljs-built_in">echo</span> <span class="hljs-string">'deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen'</span> | tee /etc/apt/sources.list.d/mongodb.list
RUN apt-get update
RUN apt-get install -y mongodb-org

<span class="hljs-comment"># 设置工作目录</span>
WORKDIR /srv/full

<span class="hljs-comment"># 清空已存在的文件（如果有）</span>
RUN rm -rf /srv/full

<span class="hljs-comment"># 通过 Git 下载准备好的 MEAN 架构的网站代码</span>
RUN git <span class="hljs-built_in">clone</span> https://github.com/chuyik/fullstack-demo-dist.git .

<span class="hljs-comment"># 安装 NodeJS 依赖库</span>
RUN npm install --production

<span class="hljs-comment"># 创建 mongodb 数据文件夹</span>
RUN mkdir -p /data/db

<span class="hljs-comment"># 暴露端口（分别是 NodeJS 应用和 Mongodb）</span>
EXPOSE <span class="hljs-number">5566</span> <span class="hljs-number">27017</span>

<span class="hljs-comment"># 设置 NodeJS 应用环境变量</span>
ENV NODE_ENV=production PORT=<span class="hljs-number">5566</span>

<span class="hljs-comment"># 添加启动脚本</span>
ADD start.sh /tmp/
RUN chmod +x /tmp/start.sh

<span class="hljs-comment"># 设置启动时默认运行命令</span>
CMD [<span class="hljs-string">"bash"</span>, <span class="hljs-string">"/tmp/start.sh"</span>]</code></pre>
</li>
<li><p>创建 start.sh 启动脚本</p>
<pre><code class="bash"><span class="hljs-comment"># 后台启动 Mongodb</span>
mongod --fork --logpath=/var/<span class="hljs-built_in">log</span>/mongo.log --logappend

<span class="hljs-comment"># 运行 NodeJS 应用</span>
npm start</code></pre>
</li>
</ol>
<h3>构建镜像</h3>
<pre><code class="bash">  <span class="hljs-comment"># 通过该命令，按照 Dockerfile 所配置的信息构建出镜像</span>
  docker build --rm -t node-full .

  <span class="hljs-comment"># 检查镜像是否创建成功</span>
  docker images</code></pre>
<h3>运行镜像</h3>
<pre><code class="bash">  <span class="hljs-comment"># 对于 Mac 或 Windows 来说，要先查看 boot2docker 的 IP</span>
  boot2docker ip

  <span class="hljs-comment"># 运行刚刚创建的镜像</span>
  <span class="hljs-comment"># -p 设置端口，格式为「主机端口:容器端口」</span>
  docker run -p <span class="hljs-number">5566</span>:<span class="hljs-number">5566</span> node-full</code></pre>
<h3>访问网页</h3>
<p>若终端打印出以下命令，则部署成功。</p>
<blockquote>
<p> about to fork child process, waiting until server is ready for connections.<br>    forked process: 9<br>  child process started successfully, parent exiting<br> demo@0.0.0 start /srv<br> node server/app.js<br>  Express server listening on 5566, in production mode</p>
</blockquote>
<p>可以用浏览器访问 <code>http://&lt;boot2docker ip&gt;:5566</code>，或运行 <code>curl -s &quot;$(boot2docker ip):5566&quot;</code>。</p>
<h2>保存 Mongodb 数据文件</h2>
<p>由于 Mongodb 服务运行在 Docker 容器 (container) 中，所以数据也在里面，但这并不利于数据管理和保存。因此，可以通过一些方法，将 Mongodb 数据文件保存在容器的外头。</p>
<h3>磁盘映射</h3>
<p>这个是最简单的方式，在 <code>docker run</code> 命令当中，就有磁盘映射的参数 <code>-v</code>。</p>
<pre><code class="bash"><span class="hljs-comment"># -v 磁盘映射，格式为「主机目录:容器目录」</span>
docker run -p <span class="hljs-number">5566</span>:<span class="hljs-number">5566</span> -v /var/mongodata:/data/db node-full</code></pre>
<p>但这个命令在 Mac 和 Windows 中执行失败，因为 boot2docker 的虚拟机不支持。<br>所以，可以将数据保存在 boot2docker 内，并设置共享文件夹便于 Mac 或 Windows 访问。</p>
<h3>Mac 的磁盘映射方案</h3>
<pre><code class="bash"><span class="hljs-comment"># 在 boot2docker 中，运行该命令</span>
boot2docker ssh
<span class="hljs-comment"># 进入 bash 后，创建存放 Mongodb 数据库文件的目录</span>
sudo mkdir -p /mnt/sda1/dev

<span class="hljs-comment"># Mac 用户通过 brew 安装 sshfs</span>
brew install sshfs
<span class="hljs-comment"># 通过 sshfs，把 /mnt/sda1/dev 挂载到 Mac 中</span>
<span class="hljs-comment"># 注：boot2docker 的默认用户为 docker/tcuser</span>
<span class="hljs-built_in">echo</span> tcuser | sshfs docker@localhost:/mnt/sda1/dev /var/mongodata -p <span class="hljs-number">2022</span> -o password_stdin

<span class="hljs-comment"># 运行镜像测试（映射 boot2docker 的目录）</span>
docker run -p <span class="hljs-number">5566</span>:<span class="hljs-number">5566</span> -v /mnt/sda1/dev:/data/db node-full</code></pre>
<h2>优化建议</h2>
<h3>将 NodeJS 和 Mongodb 分开</h3>
<p>上个例子中，我们把 NodeJS 和 Mongodb 放进了同一个镜像中，但本着一次只做一件事的原则，将其放进不同的镜像可能会更好。但分开后，NodeJS 和 Mongodb 运行的容器该如何关联呢？这里不展开介绍，有兴趣可以查阅该<a href="http://www.luiselizondo.net/how-to-create-a-docker-node-js-mongodb-varnish-environment/">博文</a>。</p>
<h3>使用进程管理工具</h3>
<p>上个例子中，我们通过 bash 脚本来运行多个命令，但也可以用一些进程管理工具来配置进程，如 <a href="http://supervisord.org/introduction.html">Supervisor</a>。整合的方式可以查阅官方教程 <a href="https://docs.docker.com/articles/using_supervisord/">Using Supervisor with Docker</a>。</p>
<h2>一些有用的 Docker 命令</h2>
<h3>查看后台运行容器的日志</h3>
<pre><code class="bash">docker ps <span class="hljs-operator">-l</span>
docker logs &lt;container_id&gt;</code></pre>
<h3>开始和关闭容器的运行</h3>
<pre><code class="bash">docker stop &lt;container_id&gt;
docker start -i &lt;container_id&gt;
docker restart -i &lt;container_id&gt;</code></pre>
<h3>运行镜像的bash</h3>
<pre><code class="bash"><span class="hljs-comment"># -i 将命令的输出信息重定向到 stdout</span>
<span class="hljs-comment"># -t 开启 tty 终端，这样就能够输入指令</span>
docker run -it ubuntu:<span class="hljs-number">14.10</span> bash</code></pre>
<h3>导入和导出镜像</h3>
<pre><code class="bash">docker save ubuntu:<span class="hljs-number">14.10</span> &gt; ubuntu_14.<span class="hljs-number">10</span>.tar
sudo docker ubuntu:<span class="hljs-number">14.10</span> &lt; ubuntu_14.<span class="hljs-number">10</span>.tar</code></pre>
<h3>停止和删除所有容器</h3>
<blockquote>
<p>来自 <a href="https://coderwall.com/p/ewk0mq/stop-remove-all-docker-containers">Fabio Rehm</a></p>
</blockquote>
<pre><code class="bash">docker stop $(docker ps <span class="hljs-operator">-a</span> -q)
docker rm $(docker ps <span class="hljs-operator">-a</span> -q)</code></pre>
<h2>参考文章 Credits</h2>
<p><a href="https://docs.docker.com/examples/nodejs_web_app/">Dockerizing a Node.js Web App</a><br><a href="http://tech.uc.cn/?p=2726">利用Docker构建开发环境 | UC技术博客</a><br><a href="http://docs.docker.com/reference/builder">Dockerfile - Docker Documentation</a><br><a href="http://docs.docker.com/reference/commandline/cli/">Command line - Docker Documentation</a><br><a href="https://docs.docker.com/articles/using_supervisord/">Using Supervisor - Docker Documentation</a><br><a href="http://www.luiselizondo.net/how-to-create-a-docker-node-js-mongodb-varnish-environment/">How to create a Docker + Node.js + MongoDB + Varnish environment</a><br><a href="https://gist.github.com/codeinthehole/7ea69f8a21c67cc07293">How to share folders with docker containers on OSX</a></p>
]]></description><pubDate>Tue Dec 30 2014 08:00:00 GMT+0800 (CST)</pubDate><link>http://edwardchu.org/articles/docker-node-app.html</link><guid isPermaLink="true">http://edwardchu.org/articles/docker-node-app.html</guid></item><item><title>Ubuntu 部署 NodeJS 应用</title><description><![CDATA[<h1>安装git</h1>
<pre><code class="bash">sudo apt-get install git</code></pre>
<h1>添加用户</h1>
<pre><code class="bash">sudo adduser git <span class="hljs-comment"># 创建一个叫 git 的用户</span>
passwd git       <span class="hljs-comment"># 设置密码（可选）</span></code></pre>
<h1>管理公钥</h1>
<p><a href="http://git-scm.com/book/zh/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5">服务器上的 Git - 生成 SSH 公钥</a></p>
<pre><code>cat ~/.ssh/id_rsa.pub | pbcopy</code></pre>
<p>将所有用户的公钥放在 <code>/home/git/.ssh/</code> 目录下。将所有的pub内容导入到 <code>/home/git/.ssh/authorized_keys</code> 文件里。</p>
<h1>禁用git用户shell登录</h1>
<p>修改 <code>/etc/passwd</code> 文件：</p>
<p>将<br><code>git:x:1000:1000:,,,:/home/git:/bin/bash</code><br>改为<br><code>git:x:1000:1000:,,,:/home/git:/usr/bin/git-shell</code></p>
<h1>初始化Git仓库</h1>
<pre><code class="bash"><span class="hljs-built_in">cd</span> /home/git/
sudo git init --bare test.git  <span class="hljs-comment"># 创建一个叫 test 的git仓库</span>
sudo chown -R git:git test.git <span class="hljs-comment"># 修改文件权限</span></code></pre>
<h1>克隆远程仓库</h1>
<p>现在可以在客户端运行git clone命令克隆远程仓库了。</p>
<pre><code class="bash">git <span class="hljs-built_in">clone</span> git@&lt;SERVER_IP&gt;:/home/git/test.git  <span class="hljs-comment"># 下载 test 仓库</span></code></pre>
<h1>钩子</h1>
<p>在服务端的 Git 仓库创建 <code>hooks/post-receive</code> 文件，设置权限 <code>chmod +x post-receive</code><br>利用 <code>node-foreman</code> 进行部署</p>
<pre><code class="bash"><span class="hljs-shebang">#!/bin/sh</span>
<span class="hljs-built_in">export</span> GIT_WORK_TREE=<span class="hljs-string">"/home/quiz/app"</span>

<span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-variable">$GIT_WORK_TREE</span>"</span> || <span class="hljs-built_in">exit</span>
<span class="hljs-built_in">unset</span> GIT_DIR

<span class="hljs-built_in">echo</span> <span class="hljs-string">"--&gt; Running deploy script..."</span>
nohup sh <span class="hljs-variable">$GIT_WORK_TREE</span>/deploy.sh &gt; <span class="hljs-variable">$GIT_WORK_TREE</span>/out.log <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> %
tail <span class="hljs-variable">$GIT_WORK_TREE</span>/out.log <span class="hljs-operator">-f</span></code></pre>
<p>创建 <code>deploy.sh</code></p>
<pre><code class="bash"><span class="hljs-shebang">#!/bin/sh
</span>
SERVICE=<span class="hljs-string">"node server/app.js"</span>

<span class="hljs-keyword">if</span> ps ax | grep -v grep | grep <span class="hljs-string">"<span class="hljs-variable">$SERVICE</span>"</span> &gt; /dev/null
<span class="hljs-keyword">then</span>
    SREVICE_ID=`ps aux | grep <span class="hljs-string">"<span class="hljs-variable">$SERVICE</span>"</span> | grep -v grep | awk <span class="hljs-string">'{print $2}'</span>`
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$SERVICE</span> service already running, with process id <span class="hljs-variable">$SREVICE_ID</span>..Trying to kill it..."</span>
    <span class="hljs-built_in">kill</span> <span class="hljs-variable">$SREVICE_ID</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$SERVICE</span> is not running"</span>
<span class="hljs-keyword">fi</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"--&gt; Pulling latest..."</span>
git pull origin master

<span class="hljs-built_in">echo</span> <span class="hljs-string">"--&gt; Restarting app..."</span>
nf stop
nf start web=<span class="hljs-number">2</span></code></pre>
<p>确保 git 有访问这个 <code>deploy.sh</code> 的权限，保证 kill 命令能被执行。</p>
<pre><code class="bash">usermod <span class="hljs-operator">-a</span> -G group git  <span class="hljs-comment"># add a existing user to existing group</span>
chgrp group /home/quiz/app/deploy.sh</code></pre>
<h1>负载均衡</h1>
<ol>
<li><p>安装 nginx</p>
<pre><code class="bash">apt-get install nginx</code></pre>
</li>
<li><p>修改 nginx 配置文件</p>
<pre><code class="bash">vi etc/nginx/sites-available/default</code></pre>
</li>
</ol>
<p>内容：</p>
<pre><code>upstream node_server_pool {
   server &lt;IP&gt;:5000 max_fails=1;
   server &lt;IP&gt;:5001 max_fails=1;
}
server {
  listen       80;
  server_name  120.24.240.228;
  location /
   {
    proxy_pass http://node_server_pool;
    proxy_set_header Host &lt;IP&gt;:80;
    proxy_set_header X-Forwarded-For $remote_addr;
   }
}</code></pre>
<ol>
<li>重启 nginx<pre><code class="bash">/etc/init.d/nginx restart</code></pre>
</li>
</ol>
<h1>解决 Host key verification failed 的问题</h1>
<p>因为是由服务器的 git 用户触发 git hook，所以脚本中调用的 <code>git pull origin master</code> 会报错，这时只要把 git 的 id_rsa.pub 内容复制到 quiz 的 authorized_keys，再用 git ssh 登录 quiz 一次，就可以了。</p>
]]></description><pubDate>Wed Mar 05 2014 08:00:00 GMT+0800 (CST)</pubDate><link>http://edwardchu.org/articles/ubuntu-git-server.html</link><guid isPermaLink="true">http://edwardchu.org/articles/ubuntu-git-server.html</guid></item><item><title>HTML/JS/CSS Hack Collection</title><description><![CDATA[<p>Here are some funny hacks for your web browser, mostly collected from Internet,
<br>
which may save your day or make you lol.
</p><!-- more --><p>Hacks would be classified into three parts and showed in separate pages above.
</p><h2>Credits</h2>
<p><a href="http://www.quora.com/What-are-the-most-interesting-HTML-JS-DOM-CSS-hacks-that-most-web-developers-dont-know-about">Dockerizing a Node.js Web App</a><br><a href="http://www.cnblogs.com/wayou/p/things_you_dont_know_about_frontend.html">前端不为人知的一面--前端冷知识集锦</a></p>
]]></description><pubDate>Sun Dec 28 2014 08:00:00 GMT+0800 (CST)</pubDate><link>http://edwardchu.org/articles/html-hack-collection.html</link><guid isPermaLink="true">http://edwardchu.org/articles/html-hack-collection.html</guid></item></channel></rss>